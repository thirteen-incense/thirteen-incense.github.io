<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2020-10-05 Mon 17:44 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>网络编程</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Jack Liu">
<link rel="shortcut icon" href="/images/rose-red.png" type="image/x-icon" />
<link rel="stylesheet" href="/css/animate.min.css" />
<link rel="stylesheet" href="/css/all.min.css" />
<link rel="stylesheet" type="text/css" href="/css/style.css" />
<script src="/js/jquery.min.js"></script>
<script src="/js/darkreader.js"></script>
<script src="/user.config.js"></script>
<script src="/js/main.js"></script>
</head>
<body>
<div id="content">
<h1 class="title">网络编程</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgd59213c">网络编程基础</a>
<ul>
<li><a href="#org23030b5">IP 地址</a></li>
<li><a href="#org834eb0c">域名</a></li>
<li><a href="#org7bc1c71">网络模型</a></li>
<li><a href="#org6bf170c">常用协议</a></li>
<li><a href="#orgb214c98">网络基本概念小结</a></li>
</ul>
</li>
<li><a href="#org47f939a">TCP 编程</a>
<ul>
<li><a href="#org816a8cd">服务器端</a></li>
<li><a href="#org9bb8eef">客户端</a></li>
<li><a href="#orge543541">Socket 流</a></li>
<li><a href="#org00ca885">TCP 编程小结</a></li>
</ul>
</li>
<li><a href="#orgf7d0de4">UDP 编程</a>
<ul>
<li><a href="#org12206ea">服务器端</a></li>
<li><a href="#orga7e54a1">客户端</a></li>
<li><a href="#org22443cc">UDP 编程小结</a></li>
</ul>
</li>
<li><a href="#orgbddb4e5">HTTP 编程</a>
<ul>
<li><a href="#org538a472">HTTP 请求</a></li>
<li><a href="#org769a935">HTTP 响应</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
摘录自 → <a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255945371526048">网络编程·廖雪峰</a>
</p>

<p>
网编编程是 Java 最擅长的方向之一，使用 Java 进行网络编程时，由虚拟机实现了底层复杂的网编协议，Java 程序只需要调用 Java 标准库提供的接口，就可以简单地编写网络程序。
</p>

<img
src="/images/java/java-15.jpg"
width="300"
height=""
style=""
title=""
/>

<div id="outline-container-orgd59213c" class="outline-2">
<h2 id="orgd59213c">网络编程基础</h2>
<div class="outline-text-2" id="text-orgd59213c">
<p>
在学习 Java 网络编程之前，我们先来了解什么是计算机网络。
</p>

<p>
计算机网络是指两台或更多的计算机组成的网络，在同一个网络中，任意两台计算机都可以直接通信，因为所有计算机都需要遵循同一种网络协议。像这样，把很多计算机网络连接起来形成的一个全球统一的网络，就是 <span class="underline">互联网</span> 。
</p>

<p>
如果计算机网络各自在通讯协议不统一，就没法把不同的网络连接起来形成互联网，因此，为了把计算机网络接入互联网，就必须使用 TCP/IP 协议。
</p>
</div>

<div id="outline-container-org23030b5" class="outline-3">
<h3 id="org23030b5">IP 地址</h3>
<div class="outline-text-3" id="text-org23030b5">
<p>
i.e. Internet Protocol
</p>

<p>
在互联网中，一个 IP 地址用于唯一标识一个网络接口（Network Interface），一台联入互联网的计算机至少有一个 IP 地址。
</p>

<p>
IP 地址分为 IPv4 和 IPv6 两种。IPv4 采用 32 位地址，类似于 <code>101.202.99.12</code> ，而 IPv6 采用 128 位地址，类似 <code>2001:0DA8:100A:0000:0000:1020:F2F3:1428</code> 。IPv4 地址总共有 2<sup>32</sup> 个（大约 42 亿），而 IPv6 地址则总共有 2<sup>128</sup> 个（大约 340 万亿亿亿亿），IPv4 的地址目前已经耗尽，而 IPv6 的地址是根本用不完的。
</p>

<p>
IP 地址又分为公网 IP 地址（可以直接被访问）和内网 IP 地址（只能在内网访问）。
</p>

<p>
内网 IP 地址类似于： <code>192.168.x.x</code> 、 <code>10.x.x.x</code> ，还有一个特殊的 IP 地址，称之为本机地址，它总是 <code>127.0.0.1</code> 。
</p>

<p>
IPv4 地址实际上是一个 32 位整数，如：
</p>

<table>

<colgroup>
<col  class="org-center">

<col  class="org-center">
</colgroup>
<tbody>
<tr>
<td class="org-center"><code>106717964</code></td>
<td class="org-center"><code>0x65ca630c</code></td>
</tr>

<tr>
<td class="org-center">&#xa0;</td>
<td class="org-center"><code>65 ca 63 0c</code></td>
</tr>

<tr>
<td class="org-center">&#xa0;</td>
<td class="org-center"><code>101.202.99.12</code></td>
</tr>
</tbody>
</table>

<p>
如果一台计算机只有一个网卡，并且接入了网络，那么，它有一个本机地址 <code>127.0.0.1</code> ，还有一个 IP 地址，例如 <code>101.202.99.12</code> ，可以通过这个 IP 地址接入网络。
</p>

<p>
如果一台计算机有两块网卡，那么除了本机地址，它可以有两个 IP 地址，可以分别接入两个网络。通常连接两个网络的设备是路由器或者交换机，它至少有两个 IP 地址，分别接入不同的网络，让网络之间连接起来。
</p>

<p>
如果两台计算机位于同一个网络，那么他们之间可以直接通信，因为他们的 IP 地址是相同的，也就是网络号是相同的。
</p>

<p>
网络号是 IP 地址通过子网掩码过滤后得到的。
</p>

<p>
例如：某台计算机的 IP 是 <code>101.202.99.2</code> ，子网掩码是 <code>255.255.255.0</code> ，那么该计算机的网络号是：
</p>

<table>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">IP</td>
<td class="org-left"><code>101.202.99.2</code></td>
</tr>

<tr>
<td class="org-left">Mask</td>
<td class="org-left"><code>255.255.255.0</code></td>
</tr>

<tr>
<td class="org-left">Network (IP &amp; Mask)</td>
<td class="org-left"><code>101.202.99.0</code></td>
</tr>
</tbody>
</table>

<p>
每台计算机都需要正确配置 IP 地址和子网掩码，根据这两个就可以计算网络号。如果两台计算机计算出的网络号相同，说明两台计算机在同一个网络，可以直接通信；如果网络号不同，说明两台计算机不在同个网络，不能直接通信。
</p>

<p>
不在同一网络（网络号不同）的计算机，必须通过 <b>路由器或者交换机</b> 这样的网络设备间接通信，我们把这种设备称为 <span class="underline">网关</span> 。
</p>

<p>
网关的作用就是连接多个网络，负责把来自一个网络的数据包发到另一个网络，这个过程叫 <span class="underline">路由</span> 。
</p>

<img
src="/images/java/java-16.png"
width="400"
height=""
style=""
title=""
/>
<p>
<code>Figure: 一台计算机的一个网卡的 3 个关键配置</code>
</p>
</div>
</div>

<div id="outline-container-org834eb0c" class="outline-3">
<h3 id="org834eb0c">域名</h3>
<div class="outline-text-3" id="text-org834eb0c">
<p>
IP 地址不容易记忆，所以我们通常使用域名访问某个特定的服务， <b>域名解析服务器 DNS</b> 负责把域名翻译成对应的 IP ，客户端再根据 IP 地址访问服务器。
</p>

<p>
用 <code>nslookup</code> 可以查看域名对应的 IP 地址：
</p>

<pre class="example">
$ nslookup www.rosesor.com
Server:  xxx.xxx.xxx.xxx
Address: xxx.xxx.xxx.xxx#53

Non-authoritative answer:
Name:    www.rosesor.com
Address: 192.112.245.112
</pre>

<p>
有一个特殊的本机域名 <code>localhost</code> ，它对应的 IP 地址总是本机地址 <code>127.0.0.1</code> 。
</p>
</div>
</div>

<div id="outline-container-org7bc1c71" class="outline-3">
<h3 id="org7bc1c71">网络模型</h3>
<div class="outline-text-3" id="text-org7bc1c71">
<p>
由于计算机网络从底层的传输到高层的软件设计十分复杂，要合理地设计计算机网络模型，必须采用分层模型，每一层负责处理自己的操作。
</p>

<p>
OSI（Open System Interconnect）网络模型是 ISO 组织定义的一个计算机互联的标准模型，注意它只是一个定义，目的是为了简化网络各层的操作，提供标准接口便于实现和维护。
</p>

<p>
互联网实际使用的 TCP/IP 模型并不是对应到 OSI 的 7 层模型，而是大致对应 OSI 的 5 层模型：
</p>
<table>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">TCP/IP 四层模型</th>
<th scope="col" class="org-left">TCP/IP 五层模型</th>
<th scope="col" class="org-left">OSI 模型</th>
<th scope="col" class="org-left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">应用层</td>
<td class="org-left">应用层</td>
<td class="org-left">应用层</td>
<td class="org-left">提供应用程序之间的通信</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">表示层</td>
<td class="org-left">处理数据格式，加解密等等</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">会话层</td>
<td class="org-left">负责建立和维护会话</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">传输层</td>
<td class="org-left">传输层</td>
<td class="org-left">传输层</td>
<td class="org-left">负责提供端到端的可靠传输</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">互联网层</td>
<td class="org-left">互联网层 (IP 层)</td>
<td class="org-left">网络层</td>
<td class="org-left">负责根据目标地址选择路由来传输数据</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">数据链路层</td>
<td class="org-left">数据链路层</td>
<td class="org-left">负责把数据进行分片并且真正通过物理</td>
</tr>

<tr>
<td class="org-left">网络接口层</td>
<td class="org-left">物理层</td>
<td class="org-left">物理层</td>
<td class="org-left">网络传输，例如，无线网、光纤等</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org6bf170c" class="outline-3">
<h3 id="org6bf170c">常用协议</h3>
<div class="outline-text-3" id="text-org6bf170c">
<p>
IP 协议是一个分组交换传输协议，它不保证可靠传输，而 TCP 协议是传输控制协议，它是面向连接的协议，支持可靠传输和双向通信。
</p>

<p>
TCP 协议是建立在 IP 协议之上，简单地说，IP 协议只负责发数据包，不保证顺序和正确性，而 TCP 协议负责控制数据包传输，它在传输数据之前需要先 <b>建立连接</b> ，连接建立后才能 <b>传输数据</b> ，传输完成后还需要 <b>断开连接</b> 。
</p>

<p>
TCP 协议之所以能保证数据的可靠传输，是通过接收确认、超时重传这些机制实现的。并且，TCP 协议允许双向通信，即通信双方可以同时发送和接收数据。
</p>

<p>
TCP 协议也是应用最广泛的协议，许多高级协议都是建立在 TCP 协议之上的，例如 HTTP、SMTP 等。
</p>

<p>
UDP 协议（User Datagram Protocol）是一种数据报文协议，这是元连接协议，不保证可靠传输。因为 UDP 协议在通信前不需要进行连接，所以它的传输效率比 TCP 高，而且 UDP 协议比 TCP 协议要简单得多。
</p>

<p>
选择 UDP 协议时，传输的数据通常是能容忍丢失的，例如，一些语音视频通信的应用会选择 UDP 协议。
</p>
</div>
</div>

<div id="outline-container-orgb214c98" class="outline-3">
<h3 id="orgb214c98">网络基本概念小结</h3>
<div class="outline-text-3" id="text-orgb214c98">
<ul class="org-ul">
<li>计算机网络：由两台或更多计算机组成的网络；</li>
<li>互联网：连接网络的网络；</li>
<li>IP 地址：计算机的网络接口（通常是网卡）在网络中的唯一标识；</li>
<li>网关：负责连接多个网络，并在多个网络之间转发数据的计算机，通常是路由器或交换机；</li>
<li>网络协议：互联网使用 TCP/IP 协议，它泛指互联网协议簇；</li>
<li>IP 协议：一种分组交换传输协议；</li>
<li>TCP 协议：一种面向连接，可靠传输的协议；</li>
<li>UDP 协议：一种无连接，不可靠传输的协议。</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org47f939a" class="outline-2">
<h2 id="org47f939a">TCP 编程</h2>
<div class="outline-text-2" id="text-org47f939a">
<p>
i.e. Transmission Control Protocol
</p>

<p>
在开发网络应用程序的时候，我们会遇到 Socket ，它是一个抽象概念，一个应用程序通过一个 Socket 来建立一个远程连接，而 Socket 内部通过 TCP/IP 协议把数据传输到网络：
</p>

<img
src="/images/java/java-17.png"
width=""
height=""
style=""
title=""
/>

<p>
Socket、TCP 和部分 IP 的功能都是由操作系统提供的，不同的编程语言只是提供了对操作系统调用的简单封装。例如，Java 提供的几个关于 Socket 相关的类就封装了操作系统提供的接口。
</p>

<p>
<b>为什么需要 Socket 进行网络通信？</b>
</p>

<p>
因为仅仅通过 IP 地址进行通信是不够的，同一台计算机同一时间会运行多个网络应用程序，如浏览器、QQ、音乐播放器等。当操作系统收到一个数据包的时候，如果只有 IP 地址，它没法判断应该发给哪个应用程序，所以，操作系统抽象出 Socked 接口，每个应用程序需要各自对应到不同的 Socket，数据包才能根据 Socket 正确地发到对应的应用程序。
</p>

<p>
<b>一个 Socket 就是由 IP 地址和端口号（范围中 0~65535）组成</b> ，其中，小于 <code>1024</code> 的端口属于特权端口，需要管理员权限，大于 <code>1024</code> 的端口可以由任意用户的应用程序打开。如：
</p>

<pre class="example">
IE: 101.202.99.2:1201
QQ: 101.202.99.2:1304
</pre>

<p>
<b>使用 Socket 进行网络编程时，本质上就是两个进程之间的网络通信。</b>
</p>

<p>
其中一个进程必须充当服务器端，它会主动监听某个指定的端口，另一个进程必须充当客户端，它必须主动连接服务器的 IP 地址和指定端口。如果连接成功，服务器和客户端就成功地建立了一个 TCP 连接，双方后续就可以随时发送和接收数据。
</p>

<p>
当 Socket 连接成功地在服务器端和客户端之间建立后：
</p>
<ul class="org-ul">
<li>对服务器端来说，它的 Socket 是指定的 IP 地址和指定的端口号；</li>
<li>对客户端来说，它的 Socket 是它所在计算机的 IP 地址和一个由操作系统分配的随端口号。</li>
</ul>
</div>

<div id="outline-container-org816a8cd" class="outline-3">
<h3 id="org816a8cd">服务器端</h3>
<div class="outline-text-3" id="text-org816a8cd">
<p>
要全用 Socket 编程，我们首先要编写服务器端程序。
</p>

<p>
Java 标准库提供了 <code>ServerSocket</code> 来实现对指定 IP 和指定端口的监听，其典型实现代码如下：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #F92672;">public</span> <span style="color: #F92672;">class</span> <span style="color: #66D9EF;">Server</span> <span style="color: #AE81FF;">{</span>
<span class="linenr"> 2: </span>    <span style="color: #F92672;">public</span> <span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">main</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">String</span><span style="color: #A6E22E;">[]</span> <span style="color: #FD971F;">args</span><span style="color: #66D9EF;">)</span> <span style="color: #F92672;">throws</span> <span style="color: #66D9EF;">IOException</span> <span style="color: #66D9EF;">{</span>
<span class="linenr"> 3: </span>        <span style="color: #66D9EF;">ServerSocket</span> <span style="color: #FD971F;">ss</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">ServerSocket</span><span style="color: #A6E22E;">(</span>6666<span style="color: #A6E22E;">)</span>; <span style="color: #75715E;">// </span><span style="color: #75715E;">&#30417;&#21548;&#25351;&#23450;&#31471;&#21475;</span>
<span class="linenr"> 4: </span>        System.out.println<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"Server is running..."</span><span style="color: #A6E22E;">)</span>;
<span class="linenr"> 5: </span>        <span style="color: #F92672;">for</span> <span style="color: #A6E22E;">(</span>;;<span style="color: #A6E22E;">)</span> <span style="color: #A6E22E;">{</span>
<span class="linenr"> 6: </span>            <span style="color: #66D9EF;">Socket</span> <span style="color: #FD971F;">sock</span> == ss.accept<span style="color: #E6DB74;">()</span>;
<span class="linenr"> 7: </span>            System.out.println<span style="color: #E6DB74;">(</span><span style="color: #E6DB74;">"connected from "</span> + sock.getRemoteSocketAddress<span style="color: #FD971F;">()</span><span style="color: #E6DB74;">)</span>;
<span class="linenr"> 8: </span>            <span style="color: #66D9EF;">Thread</span> <span style="color: #FD971F;">t</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">Handler</span><span style="color: #E6DB74;">(</span>sock<span style="color: #E6DB74;">)</span>;
<span class="linenr"> 9: </span>            t.start<span style="color: #E6DB74;">()</span>;
<span class="linenr">10: </span>        <span style="color: #A6E22E;">}</span>
<span class="linenr">11: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">12: </span><span style="color: #AE81FF;">}</span>
<span class="linenr">13: </span>
<span class="linenr">14: </span><span style="color: #F92672;">class</span> <span style="color: #66D9EF;">Handler</span> <span style="color: #F92672;">extends</span> <span style="color: #66D9EF;">Thread</span> <span style="color: #AE81FF;">{</span>
<span class="linenr">15: </span>    <span style="color: #66D9EF;">Socked</span> <span style="color: #FD971F;">sock</span>;
<span class="linenr">16: </span>
<span class="linenr">17: </span>    <span style="color: #F92672;">public</span> <span style="color: #A6E22E;">Handler</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">Socket</span> <span style="color: #FD971F;">sock</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr">18: </span>        <span style="color: #F92672;">this</span>.sock = sock;
<span class="linenr">19: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">20: </span>
<span class="linenr">21: </span>    <span style="color: #AE81FF;">@Override</span>
<span class="linenr">22: </span>    <span style="color: #F92672;">public</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">run</span><span style="color: #66D9EF;">()</span> <span style="color: #66D9EF;">{</span>
<span class="linenr">23: </span>        <span style="color: #F92672;">try</span> <span style="color: #A6E22E;">(</span><span style="color: #66D9EF;">InputStream</span> <span style="color: #FD971F;">input</span> = <span style="color: #F92672;">this</span>.sock.getInputStream<span style="color: #E6DB74;">()</span><span style="color: #A6E22E;">)</span> <span style="color: #A6E22E;">{</span>
<span class="linenr">24: </span>            <span style="color: #F92672;">try</span> <span style="color: #E6DB74;">(</span><span style="color: #66D9EF;">OutputStream</span> <span style="color: #FD971F;">output</span> = <span style="color: #F92672;">this</span>.sock.getOutputStream<span style="color: #FD971F;">()</span><span style="color: #E6DB74;">)</span> <span style="color: #E6DB74;">{</span>
<span class="linenr">25: </span>                handle<span style="color: #FD971F;">(</span>input, output<span style="color: #FD971F;">)</span>;
<span class="linenr">26: </span>            <span style="color: #E6DB74;">}</span>
<span class="linenr">27: </span>
<span class="linenr">28: </span>        <span style="color: #A6E22E;">}</span> <span style="color: #F92672;">catch</span> <span style="color: #A6E22E;">(</span><span style="color: #66D9EF;">Exception</span> <span style="color: #FD971F;">e</span><span style="color: #A6E22E;">)</span> <span style="color: #A6E22E;">{</span>
<span class="linenr">29: </span>            <span style="color: #F92672;">try</span> <span style="color: #E6DB74;">{</span>
<span class="linenr">30: </span>                <span style="color: #F92672;">this</span>.sock.close<span style="color: #FD971F;">()</span>;
<span class="linenr">31: </span>            <span style="color: #E6DB74;">}</span> <span style="color: #F92672;">catch</span> <span style="color: #E6DB74;">(</span><span style="color: #66D9EF;">IOException</span> <span style="color: #FD971F;">ioe</span><span style="color: #E6DB74;">)</span> <span style="color: #E6DB74;">{</span>
<span class="linenr">32: </span>            <span style="color: #E6DB74;">}</span>
<span class="linenr">33: </span>            System.out.println<span style="color: #E6DB74;">(</span><span style="color: #E6DB74;">"client disconnected."</span><span style="color: #E6DB74;">)</span>;
<span class="linenr">34: </span>        <span style="color: #A6E22E;">}</span>
<span class="linenr">35: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">36: </span><span style="color: #AE81FF;">}</span>
<span class="linenr">37: </span>
<span class="linenr">38: </span><span style="color: #F92672;">private</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">handle</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">InputStream</span> <span style="color: #FD971F;">input</span>, <span style="color: #66D9EF;">OutputStream</span> <span style="color: #FD971F;">output</span><span style="color: #AE81FF;">)</span> <span style="color: #F92672;">throws</span> <span style="color: #66D9EF;">IOException</span> <span style="color: #AE81FF;">{</span>
<span class="linenr">39: </span>    <span style="color: #66D9EF;">var</span> <span style="color: #FD971F;">writer</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">BufferedWriter</span><span style="color: #66D9EF;">(</span><span style="color: #F92672;">new</span> <span style="color: #66D9EF;">OutputStreamWriter</span><span style="color: #A6E22E;">(</span>output, <span style="color: #AE81FF;">StandardCharsets</span>.UTF_8<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span>;
<span class="linenr">40: </span>    <span style="color: #66D9EF;">var</span> <span style="color: #FD971F;">reader</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">BufferedReader</span><span style="color: #66D9EF;">(</span><span style="color: #F92672;">new</span> <span style="color: #66D9EF;">InputStreamReader</span><span style="color: #A6E22E;">(</span>input, <span style="color: #AE81FF;">StandardCharsets</span>.UTF_8<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span>;
<span class="linenr">41: </span>    writer.write<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">"hello\n"</span><span style="color: #66D9EF;">)</span>;
<span class="linenr">42: </span>    writer.flush<span style="color: #66D9EF;">()</span>;
<span class="linenr">43: </span>    <span style="color: #F92672;">for</span><span style="color: #66D9EF;">(</span>;;<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr">44: </span>        <span style="color: #66D9EF;">String</span> <span style="color: #FD971F;">s</span> = reader.readLine<span style="color: #A6E22E;">()</span>;
<span class="linenr">45: </span>        <span style="color: #F92672;">if</span> <span style="color: #A6E22E;">(</span>s.equals<span style="color: #E6DB74;">(</span><span style="color: #E6DB74;">"bye"</span><span style="color: #E6DB74;">)</span><span style="color: #A6E22E;">)</span> <span style="color: #A6E22E;">{</span>
<span class="linenr">46: </span>            writer.write<span style="color: #E6DB74;">(</span><span style="color: #E6DB74;">"bye\n"</span><span style="color: #E6DB74;">)</span>;
<span class="linenr">47: </span>            writer.flush<span style="color: #E6DB74;">()</span>;
<span class="linenr">48: </span>            <span style="color: #F92672;">break</span>;
<span class="linenr">49: </span>        <span style="color: #A6E22E;">}</span>
<span class="linenr">50: </span>        writer.write<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"ok: "</span> + s + <span style="color: #E6DB74;">"\n"</span><span style="color: #A6E22E;">)</span>;
<span class="linenr">51: </span>        writer.flush<span style="color: #A6E22E;">()</span>;
<span class="linenr">52: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">53: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
让我们来分析一下上面的代码吧。
</p>

<p>
服务器端通过代码：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr">1: </span><span style="color: #66D9EF;">ServerSocket</span> <span style="color: #FD971F;">ss</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">ServerSocket</span><span style="color: #AE81FF;">(</span>6666<span style="color: #AE81FF;">)</span>;
</pre>
</div>

<p>
在指定端口 <code>6666</code> 监听，此处没有指定 IP 地址，表示在计算机的所有网络接口上进行监听。
</p>

<p>
如果 <code>ServerSocket</code> 监听成功，我们就使用一个无限循环来处理客户端的连接：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr">1: </span><span style="color: #F92672;">for</span><span style="color: #AE81FF;">(</span>;;<span style="color: #AE81FF;">)</span> <span style="color: #AE81FF;">{</span>
<span class="linenr">2: </span>    <span style="color: #66D9EF;">Socket</span> <span style="color: #FD971F;">sock</span> = ss.accept<span style="color: #66D9EF;">()</span>;
<span class="linenr">3: </span>    <span style="color: #66D9EF;">Thread</span> <span style="color: #FD971F;">t</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">Handler</span><span style="color: #66D9EF;">(</span>sock<span style="color: #66D9EF;">)</span>;
<span class="linenr">4: </span>    t.start<span style="color: #66D9EF;">()</span>;
<span class="linenr">5: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
注意到代码 <code>ss.accept()</code> 表示每当有新的客户端连接进来后，就返回一个 <code>Socket</code> 实例，这个 <code>Socket</code> 实例就是用来和刚连接的客户端进行通信的。由于客户端很多，要实现并发处理，我们就必须为每个新的 <code>Socket</code> 创建一个新线程来处理，这样，主线程的作用就是接收新的连接，每当收到新连接后，就创建一个新线程进行处理。
</p>

<blockquote>
<p>
我们还可以利用线程池来处理客户端连接，能大大提高运行效率。
</p>
</blockquote>

<p>
如果客户端连接进来， <code>accept()</code> 方法会阻塞并一直等待。如果有多个客户端同时连接进来， <code>ServerSocket</code> 会把连接扔到队列里，然后一个一个处理。对于 Java 程序而言，只需要通过循环不断调用 <code>accept()</code> 就可以获取新的连接。
</p>
</div>
</div>

<div id="outline-container-org9bb8eef" class="outline-3">
<h3 id="org9bb8eef">客户端</h3>
<div class="outline-text-3" id="text-org9bb8eef">
<p>
相比服务器端，客户端程序就要简单很多。一个典型的客户端程序如下：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #F92672;">public</span> <span style="color: #F92672;">class</span> <span style="color: #66D9EF;">Client</span> <span style="color: #AE81FF;">{</span>
<span class="linenr"> 2: </span>    <span style="color: #F92672;">public</span> <span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">main</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">String</span><span style="color: #A6E22E;">[]</span> <span style="color: #FD971F;">args</span><span style="color: #66D9EF;">)</span> <span style="color: #F92672;">throws</span> <span style="color: #66D9EF;">IOException</span> <span style="color: #66D9EF;">{</span>
<span class="linenr"> 3: </span>        <span style="color: #66D9EF;">Socket</span> <span style="color: #FD971F;">sock</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">Socket</span><span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"localhost"</span>, 6666<span style="color: #A6E22E;">)</span>; <span style="color: #75715E;">// </span><span style="color: #75715E;">&#36830;&#25509;&#25351;&#23450;&#26381;&#21153;&#22120;&#21644;&#31471;&#21475;</span>
<span class="linenr"> 4: </span>        <span style="color: #F92672;">try</span> <span style="color: #A6E22E;">(</span><span style="color: #66D9EF;">InputStream</span> <span style="color: #FD971F;">input</span> = sock.getInputStream<span style="color: #E6DB74;">()</span><span style="color: #A6E22E;">)</span> <span style="color: #A6E22E;">{</span>
<span class="linenr"> 5: </span>            <span style="color: #F92672;">try</span> <span style="color: #E6DB74;">(</span><span style="color: #66D9EF;">OutputStream</span> <span style="color: #FD971F;">output</span> = sock.getOutputStream<span style="color: #FD971F;">()</span><span style="color: #E6DB74;">)</span> <span style="color: #E6DB74;">{</span>
<span class="linenr"> 6: </span>                handle<span style="color: #FD971F;">(</span>input, output<span style="color: #FD971F;">)</span>;
<span class="linenr"> 7: </span>            <span style="color: #E6DB74;">}</span>
<span class="linenr"> 8: </span>        <span style="color: #A6E22E;">}</span>
<span class="linenr"> 9: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">10: </span>
<span class="linenr">11: </span>    <span style="color: #F92672;">private</span> <span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">handle</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">InputStream</span> <span style="color: #FD971F;">input</span>, <span style="color: #66D9EF;">OutputStream</span> <span style="color: #FD971F;">output</span><span style="color: #66D9EF;">)</span> <span style="color: #F92672;">throws</span> <span style="color: #66D9EF;">IOException</span> <span style="color: #66D9EF;">{</span>
<span class="linenr">12: </span>        <span style="color: #66D9EF;">var</span> <span style="color: #FD971F;">writer</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">BufferedWriter</span><span style="color: #A6E22E;">(</span><span style="color: #F92672;">new</span> <span style="color: #66D9EF;">OutputStreamWriter</span><span style="color: #E6DB74;">(</span>output, <span style="color: #AE81FF;">StandardCharsets</span>.UTF_8<span style="color: #E6DB74;">)</span><span style="color: #A6E22E;">)</span>;
<span class="linenr">13: </span>        <span style="color: #66D9EF;">var</span> <span style="color: #FD971F;">reader</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">BufferedReader</span><span style="color: #A6E22E;">(</span><span style="color: #F92672;">new</span> <span style="color: #66D9EF;">InputStreamReader</span><span style="color: #E6DB74;">(</span>input, <span style="color: #AE81FF;">StandardCharsets</span>.UTF_8<span style="color: #E6DB74;">)</span><span style="color: #A6E22E;">)</span>;
<span class="linenr">14: </span>        <span style="color: #66D9EF;">Scanner</span> <span style="color: #FD971F;">scanner</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">Scanner</span><span style="color: #A6E22E;">(</span>System.in<span style="color: #A6E22E;">)</span>;
<span class="linenr">15: </span>        System.out.println<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"[server] "</span> + reader.readLine<span style="color: #E6DB74;">()</span><span style="color: #A6E22E;">)</span>;
<span class="linenr">16: </span>        <span style="color: #F92672;">for</span> <span style="color: #A6E22E;">(</span>;;<span style="color: #A6E22E;">)</span> <span style="color: #A6E22E;">{</span>
<span class="linenr">17: </span>            System.out.println<span style="color: #E6DB74;">(</span><span style="color: #E6DB74;">"&gt;&gt;&gt; "</span><span style="color: #E6DB74;">)</span>;    <span style="color: #75715E;">// </span><span style="color: #75715E;">&#25171;&#21360;&#25552;&#31034;</span>
<span class="linenr">18: </span>            <span style="color: #66D9EF;">String</span> <span style="color: #FD971F;">s</span> = scanner.nextLine<span style="color: #E6DB74;">()</span>; <span style="color: #75715E;">// </span><span style="color: #75715E;">&#35835;&#21462;&#19968;&#34892;&#36755;&#20837;</span>
<span class="linenr">19: </span>            writer.write<span style="color: #E6DB74;">(</span>s<span style="color: #E6DB74;">)</span>;
<span class="linenr">20: </span>            writer.newLine<span style="color: #E6DB74;">()</span>;
<span class="linenr">21: </span>            writer.flush<span style="color: #E6DB74;">()</span>;
<span class="linenr">22: </span>            <span style="color: #66D9EF;">String</span> <span style="color: #FD971F;">resp</span> = reader.readLine<span style="color: #E6DB74;">()</span>;
<span class="linenr">23: </span>            System.out.println<span style="color: #E6DB74;">(</span><span style="color: #E6DB74;">"&lt;&lt;&lt; "</span> + resp<span style="color: #E6DB74;">)</span>;
<span class="linenr">24: </span>            <span style="color: #F92672;">if</span> <span style="color: #E6DB74;">(</span>resp.equals<span style="color: #FD971F;">(</span><span style="color: #E6DB74;">"bye"</span><span style="color: #FD971F;">)</span><span style="color: #E6DB74;">)</span> <span style="color: #E6DB74;">{</span>
<span class="linenr">25: </span>                <span style="color: #F92672;">break</span>;
<span class="linenr">26: </span>            <span style="color: #E6DB74;">}</span>
<span class="linenr">27: </span>        <span style="color: #A6E22E;">}</span>
<span class="linenr">28: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">29: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
客户端程序通过：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr">1: </span><span style="color: #66D9EF;">Socked</span> <span style="color: #FD971F;">sock</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">Socket</span><span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">"localhost"</span>, 6666<span style="color: #AE81FF;">)</span>;
</pre>
</div>

<p>
连接到服务器端，注意上述代码的服务器地址是 <code>localhost</code> ，表示本机地址，端口号是 <code>6666</code> ，如果连接成功，将返回一个 <code>Socket</code> 实例，用于后续通信。
</p>
</div>
</div>

<div id="outline-container-orge543541" class="outline-3">
<h3 id="orge543541">Socket 流</h3>
<div class="outline-text-3" id="text-orge543541">
<p>
当 Socket 连接创建后成功后，无论是服务器端，还是客户端，我们都使用 <code>Socket</code> 实例进行网络通信。
</p>

<p>
因为 TCP 是一种基于流的协议，因此，Java 标准库使用 <code>InputStream</code> 和 <code>OutputStream</code> 来封装 Socket 的数据流，这样我们使用 Socket 的流，和普通 IO 流类似：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr">1: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">&#29992;&#20110;&#35835;&#21462;&#32593;&#32476;&#25968;&#25454;&#65306;</span>
<span class="linenr">2: </span><span style="color: #66D9EF;">InputStream</span> <span style="color: #FD971F;">in</span> = sock.getInputStream<span style="color: #AE81FF;">()</span>;
<span class="linenr">3: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">&#29992;&#20110;&#20889;&#20837;&#32593;&#32476;&#25968;&#25454;&#65306;</span>
<span class="linenr">4: </span><span style="color: #66D9EF;">OutputStream</span> <span style="color: #FD971F;">out</span> = sock.getOutputstream<span style="color: #AE81FF;">()</span>;
</pre>
</div>

<p>
最后，我们重点来看看，为什么写入网络数据时，要调用 <code>flush()</code> 方法。
</p>

<p>
如果不调用 <code>flush()</code> ，很可能会发现客户端和服务器都收不到数据，这并不是 Java 标准库的设计问题，而是我们以流的形式写入数据的时候，并不是一写入就立刻发送到网络，而是先写入内存缓冲区，直至缓冲区满了以后，才会一次性真正发送到网络，这样设计的目的是为了提高传输效率。
</p>

<p>
如果缓冲区很少，而我们又想强制把这些数据发送到网络，就必须调用 <code>flush()</code> 强制把缓冲区数据发送出去。
</p>
</div>
</div>

<div id="outline-container-org00ca885" class="outline-3">
<h3 id="org00ca885">TCP 编程小结</h3>
<div class="outline-text-3" id="text-org00ca885">
<p>
使用 Java 进行 TCP 编程时，需要使用 Socket 模型：
</p>
<ul class="org-ul">
<li>服务器端使用 <code>ServerSocket</code> 监听指定端口；</li>
<li>客户端使用 <code>Socket(InetAddress, port)</code> 连接服务器；</li>
<li>服务器端用 <code>accept()</code> 接收并返回 <code>Socket</code> ；</li>
<li>双方通过  <code>Socket</code> 打开 <code>InputStream/OutputStream</code> 读写数据；</li>
<li>服务器端通常使用多线程同时处理多个客户端连接，利用线程池可大幅提升效率；</li>
<li><code>flush()</code> 用于强制输出缓冲区到网络。</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgf7d0de4" class="outline-2">
<h2 id="orgf7d0de4">UDP 编程</h2>
<div class="outline-text-2" id="text-orgf7d0de4">
<p>
和 TCP 编程相比，UDP 编程就简单得多，因为 UDP 没有创建连接，数据包也是一次收发一个，所以没有流的概念。
</p>

<p>
在 Java 中使用 UDP 编程，仍然需要使用 Socket ，因为应用程序在使用 UDP 时必须指定网络接口（IP）和端口号。
</p>

<p>
*注：UDP 端口和 TCP 端口虽然都使用 <code>0~65535</code> ，但他们是两套独立的端口，即一个应用程序用 TCP 占用了端口 <code>1234</code> ，不影响另一个应用程序用 UDP 占用端口 <code>1234</code> 。
</p>
</div>

<div id="outline-container-org12206ea" class="outline-3">
<h3 id="org12206ea">服务器端</h3>
<div class="outline-text-3" id="text-org12206ea">
<p>
在服务器端，使用 UDP 也需要监听指定的端口，Java 提供了 <code>DatagramSocket</code> 来实现这个功能，代码如下：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #66D9EF;">DatagramSocket</span> <span style="color: #FD971F;">ds</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">DatagramSocket</span><span style="color: #AE81FF;">(</span>6666<span style="color: #AE81FF;">)</span>; <span style="color: #75715E;">// </span><span style="color: #75715E;">&#30417;&#21548;&#25351;&#23450;&#31471;&#21475;</span>
<span class="linenr"> 2: </span><span style="color: #F92672;">for</span> <span style="color: #AE81FF;">(</span>;;<span style="color: #AE81FF;">)</span> <span style="color: #AE81FF;">{</span>
<span class="linenr"> 3: </span>    <span style="color: #75715E;">// </span><span style="color: #75715E;">&#25968;&#25454;&#32531;&#20914;&#21306;</span>
<span class="linenr"> 4: </span>    <span style="color: #66D9EF;">byte</span><span style="color: #66D9EF;">[]</span> <span style="color: #FD971F;">buffer</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">byte</span><span style="color: #66D9EF;">[</span>1024<span style="color: #66D9EF;">]</span>;
<span class="linenr"> 5: </span>    <span style="color: #66D9EF;">DatagramPacket</span> <span style="color: #FD971F;">packet</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">DatagramPacket</span><span style="color: #66D9EF;">(</span>buffer, buffer.length<span style="color: #66D9EF;">)</span>;
<span class="linenr"> 6: </span>    ds.receive<span style="color: #66D9EF;">(</span>packet<span style="color: #66D9EF;">)</span>;                       <span style="color: #75715E;">// </span><span style="color: #75715E;">&#25910;&#21462;&#19968;&#20010; UDP &#25968;&#25454;&#21253;</span>
<span class="linenr"> 7: </span>    <span style="color: #75715E;">// </span><span style="color: #75715E;">&#25910;&#21462;&#21040;&#30340;&#25968;&#25454;&#23384;&#20648;&#22312; buffer &#20013;&#65292;&#30001; packet.getOffset()&#65292;packet.getLength() &#25351;&#23450;&#36215;&#22987;&#20301;&#32622;&#21644;&#38271;&#24230;</span>
<span class="linenr"> 8: </span>    <span style="color: #75715E;">// </span><span style="color: #75715E;">&#23558;&#20854;&#25353; UTF-8 &#32534;&#30721;&#36716;&#25442;&#20026; String</span>
<span class="linenr"> 9: </span>    <span style="color: #66D9EF;">String</span> <span style="color: #FD971F;">s</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">String</span><span style="color: #66D9EF;">(</span>packet.getData<span style="color: #A6E22E;">()</span>, packet.getOffset<span style="color: #A6E22E;">()</span>, packet.getLength<span style="color: #A6E22E;">()</span>, <span style="color: #AE81FF;">StandardCharsets</span>.UTF_8<span style="color: #66D9EF;">)</span>;
<span class="linenr">10: </span>    <span style="color: #75715E;">// </span><span style="color: #75715E;">&#21457;&#36865;&#25968;&#25454;</span>
<span class="linenr">11: </span>    <span style="color: #66D9EF;">byte</span><span style="color: #66D9EF;">[]</span><span style="color: #FD971F;">data</span> = <span style="color: #E6DB74;">"ACK"</span>.getBytes<span style="color: #66D9EF;">(</span><span style="color: #AE81FF;">StandardCharsets</span>.UTF_8<span style="color: #66D9EF;">)</span>;
<span class="linenr">12: </span>    packet.setData<span style="color: #66D9EF;">(</span>data<span style="color: #66D9EF;">)</span>;
<span class="linenr">13: </span>    ds.send<span style="color: #66D9EF;">(</span>packet<span style="color: #66D9EF;">)</span>;
<span class="linenr">14: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
服务器端首先使用如下语句指定的端口监听 UDP 数据包：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr">1: </span><span style="color: #66D9EF;">DatagramSocket</span> <span style="color: #FD971F;">ds</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">DatagramSocket</span><span style="color: #AE81FF;">(</span>6666<span style="color: #AE81FF;">)</span>;
</pre>
</div>

<p>
如果没有其他应用程序占据这个端口，那么监听成功，我们就使用一个无限循环来处理收到的 UDP 数据包：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr">1: </span><span style="color: #F92672;">for</span> <span style="color: #AE81FF;">(</span>;;<span style="color: #AE81FF;">)</span> <span style="color: #AE81FF;">{</span>
<span class="linenr">2: </span>    ...
<span class="linenr">3: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
要接收一个 UDP 数据包，需要准备一个 <code>byte[]</code> 缓冲区，并通过 <code>DatagramPacket</code> 实现接收：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr">1: </span><span style="color: #66D9EF;">byte</span><span style="color: #AE81FF;">[]</span> <span style="color: #FD971F;">buffer</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">byte</span><span style="color: #AE81FF;">[</span>1024<span style="color: #AE81FF;">]</span>;
<span class="linenr">2: </span><span style="color: #66D9EF;">DatagramPacket</span> <span style="color: #FD971F;">packet</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">DatagramPacket</span><span style="color: #AE81FF;">(</span>buffer, buffer.length<span style="color: #AE81FF;">)</span>;
<span class="linenr">3: </span>ds.receive<span style="color: #AE81FF;">(</span>packet<span style="color: #AE81FF;">)</span>;
</pre>
</div>

<p>
假设我们收取到的是一个 <code>String</code> ，那么，通过 <code>DatagramPacket</code> 返回的 <code>packet.getOffset()</code> 和 <code>packet.getLength()</code> 确定数据在缓冲区的起止位置：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr">1: </span><span style="color: #66D9EF;">String</span> <span style="color: #FD971F;">s</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">String</span><span style="color: #AE81FF;">(</span>packet.getData<span style="color: #66D9EF;">()</span>, packet.getOffset<span style="color: #66D9EF;">()</span>, packet.getLength<span style="color: #66D9EF;">()</span>, <span style="color: #AE81FF;">StandardCharsets</span>.UTF_8<span style="color: #AE81FF;">)</span>;
</pre>
</div>

<p>
当服务器收到一个 <code>DatagramPacket</code> 后，通常必须立刻回复一个或多个 UDP 包，因为客户端地址在 <code>DatagramPacket</code> 中，每次收到的 <code>DatagramPacket</code> 可能是不同的客户端，如果不回复，客户端就收不到任何 UDP 包。
</p>

<p>
发送 UDP 包也是通过 <code>DatagramPacket</code> 实现的，发送代码非常简单：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr">1: </span><span style="color: #66D9EF;">byte</span><span style="color: #AE81FF;">[]</span> <span style="color: #FD971F;">data</span> = ...
<span class="linenr">2: </span>packet.setData<span style="color: #AE81FF;">(</span>data<span style="color: #AE81FF;">)</span>;
<span class="linenr">3: </span>ds.send<span style="color: #AE81FF;">(</span>packet<span style="color: #AE81FF;">)</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-orga7e54a1" class="outline-3">
<h3 id="orga7e54a1">客户端</h3>
<div class="outline-text-3" id="text-orga7e54a1">
<p>
和服务端相比，客户端使用 UDP 时，只需要直接向服务器端发送 UDP 包，然后接收返回的 UDP 包：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #66D9EF;">DatagramSocket</span> <span style="color: #FD971F;">ds</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">DatagramSocket</span><span style="color: #AE81FF;">()</span>;
<span class="linenr"> 2: </span>ds.setSoTimeOut<span style="color: #AE81FF;">(</span>1000<span style="color: #AE81FF;">)</span>;
<span class="linenr"> 3: </span>ds.connect<span style="color: #AE81FF;">(</span>InetAddress.getByName<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">"localhost"</span><span style="color: #66D9EF;">)</span>, 6666<span style="color: #AE81FF;">)</span>; <span style="color: #75715E;">// </span><span style="color: #75715E;">&#36830;&#25509;&#25351;&#23450;&#26381;&#21153;&#22120;&#21644;&#31471;&#21475;</span>
<span class="linenr"> 4: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">&#21457;&#36865;&#65306;</span>
<span class="linenr"> 5: </span><span style="color: #66D9EF;">byte</span><span style="color: #AE81FF;">[]</span> <span style="color: #FD971F;">data</span> = <span style="color: #E6DB74;">"Hello"</span>.getBytes<span style="color: #AE81FF;">()</span>;
<span class="linenr"> 6: </span><span style="color: #66D9EF;">DatagramPacket</span> <span style="color: #FD971F;">packet</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">DatagramPacket</span><span style="color: #AE81FF;">(</span>data, data.length<span style="color: #AE81FF;">)</span>;
<span class="linenr"> 7: </span>ds.send<span style="color: #AE81FF;">(</span>packet<span style="color: #AE81FF;">)</span>;
<span class="linenr"> 8: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">&#25509;&#25910;&#65306;</span>
<span class="linenr"> 9: </span><span style="color: #66D9EF;">byte</span><span style="color: #AE81FF;">[]</span> <span style="color: #FD971F;">buffer</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">byte</span><span style="color: #AE81FF;">[</span>1024<span style="color: #AE81FF;">]</span>;
<span class="linenr">10: </span>packet = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">DatagramPacket</span><span style="color: #AE81FF;">(</span>buffer, buffer.length<span style="color: #AE81FF;">)</span>;
<span class="linenr">11: </span>ds.receive<span style="color: #AE81FF;">(</span>packet<span style="color: #AE81FF;">)</span>;
<span class="linenr">12: </span><span style="color: #66D9EF;">String</span> <span style="color: #FD971F;">resp</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">String</span><span style="color: #AE81FF;">(</span>packet.getData<span style="color: #66D9EF;">()</span>, packet.getOffset<span style="color: #66D9EF;">()</span>, packet.getLength<span style="color: #66D9EF;">()</span><span style="color: #AE81FF;">)</span>;
<span class="linenr">13: </span>ds.disconnect<span style="color: #AE81FF;">()</span>;
</pre>
</div>

<p>
客户端打开一个 <code>DatagramSocket</code> 使用以下代码：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr">1: </span><span style="color: #66D9EF;">DatagramSocket</span> <span style="color: #FD971F;">ds</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">DatagramSocket</span><span style="color: #AE81FF;">()</span>;
<span class="linenr">2: </span>ds.setSoTimeout<span style="color: #AE81FF;">(</span>1000<span style="color: #AE81FF;">)</span>;
<span class="linenr">3: </span>ds.connect<span style="color: #AE81FF;">(</span>InetAddress.getByName<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">"localhost"</span><span style="color: #66D9EF;">)</span>, 6666<span style="color: #AE81FF;">)</span>;
</pre>
</div>

<p>
客户端创建 <code>DatagramSocket</code> 实例时并不需要指定端口，而是由操作系统自动指定一个当前未使用的端口。紧接着，调用 <code>setSoTimeout(1000)</code> 设定超时 1 秒，意思是后续接收 UDP 包时，等待时间最多不会超过 1 秒，否则在没有收到 UDP 包时，客户端会无限等待下去。这一点和服务端不一样，服务器端可以无限等待，因为它本来就被设计成长时间运行。
</p>

<p>
注意到客户端的 <code>DatagramSocket</code> 还调用了一个 <code>connect()</code> 方法“连接”到指定的服务器端。
</p>

<p>
不是说 UDP 是无连接的协议吗？为啥这里需要 <code>connect()</code> ？
</p>

<p>
其实，这个 <code>connect()</code> 方法不是真连接，它是为了在客户端的 <code>DatagramSocket</code> 实例中保存服务器的 IP 和端口号，确保这个 <code>DatagramSocket</code> 实例只能往指定的地址和端口发送 UDP 包，不能往其他地址和端口发送。这么做不是 UDP 的限制，而是 Java 内置了安全检查。
</p>

<p>
如果客户端希望向两个不同的服务器发送 UDP 包，那么它必须创建两个 <code>DatagramSocket</code> 实例。
</p>

<p>
后续的收发数据和服务器端是一致的。通常来说，客户端必须先发 UDP 包，因为客户端不发 UDP 包，服务端就根本不知道客户端的地址和端口号。如果客户端认为通信结束，就可以调用 <code>disconnect()</code> 断开连接：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr">1: </span>ds.disconnect<span style="color: #AE81FF;">()</span>;
</pre>
</div>

<p>
注意到 <code>disconnect()</code> 也不是真正地断开连接，它只是清除了客户端 <code>DatagramSocket</code> 实例记录的远程服务器地址和端口号，这样， <code>DatagramSocket</code> 实例就可以连接另一个服务器端。
</p>
</div>
</div>

<div id="outline-container-org22443cc" class="outline-3">
<h3 id="org22443cc">UDP 编程小结</h3>
<div class="outline-text-3" id="text-org22443cc">
<p>
使用 UDP 协议通信时，服务器和客户端双方无需建立连接：
</p>
<ul class="org-ul">
<li>服务器端用 <code>DatagramSocket(port)</code> 监听端口；</li>
<li>客户端使用 <code>DatagramSocket.connect()</code> 指定远程地址和端口；</li>
<li>双方通过 <code>receive()</code> 和 <code>send()</code> 读写数据；</li>
<li><code>DatagramSocket</code> 没有 IO 流接口，数据被直接写入 <code>byte[]</code> 缓冲区。</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgbddb4e5" class="outline-2">
<h2 id="orgbddb4e5">HTTP 编程</h2>
<div class="outline-text-2" id="text-orgbddb4e5">
<p>
什么是 HTTP ？HTTP 就是目前使用最广泛的 Web 应用程序使用的基础协议，例如，浏览器访问网站，手机 App 访问后台服务器，都是通过 HTTP 协议实现的。
</p>

<p>
HTTP（HyperText Transfer Protocol）的缩写，超文本传输协议，它是基于 TCP 协议之上的一种“请求-响应”协议。
</p>

<p>
我们来看一下浏览器请求访问某个网站时发送的 HTTP “请求-响应”。当浏览器希望访问某个网站时，浏览器和网站服务器之间首先建立 TCP 连接，且服务器总是使用 <code>80</code> 端口和加密端口 <code>443</code> ，然后，浏览器向服务器发送一个 HTTP 请求，服务器收到后，返回一个 HTTP 响应，并且在响应中包含了 HTML 有网页内容，这样，浏览器解析 HTML 后就可以给用户显示网页了。
</p>

<p>
一个完整的 HTTP 请求-响应如下：
</p>

<img
src="/images/java/java-18.png"
width=""
height=""
style=""
title=""
/>
</div>

<div id="outline-container-org538a472" class="outline-3">
<h3 id="org538a472">HTTP 请求</h3>
<div class="outline-text-3" id="text-org538a472">
<p>
HTTP 请求的格式是固定的，它由 HTTP Header 和 HTTP Body 两部分构成。
</p>

<p>
第一行总是 <code>请求方法 路径 HTTP版本</code> ，例如， <code>GET / HTTP/1.1</code> 表示使用 <code>GET</code> 请求，路径是 <code>/</code> ，版本是 <code>HTTP/1.1</code> 。
</p>

<p>
后续的每一行都是固定的 <code>Header: Value</code> 格式，我们称为 HTTP Header， <b>服务器依靠某些特定的 Header 来识别客户端请求</b> 。例如：
</p>
<ul class="org-ul">
<li><code>Host</code> ：表示请求的域名，因为一台服务器上可能有多个网站，所以有必要依靠 <code>Host</code> 来识别用于请求；</li>
<li><code>User-Agent</code> ：表示客户端自身标识信息，不同的浏览器有不同的标识，服务器依靠 <code>User-Agent</code> 判断客户端类型；</li>
<li><code>Accept</code> ：表示客户端处理的 HTTP 响应格式， <code>*/*</code> 表示任意格式， <code>text/*</code> 表示任意文本， <code>image/png</code> 表示 PNG 格式的图片；</li>
<li><code>Accept-Language</code> ：表示客户端接收的语言，多种语言按优先级排序，服务器依靠该字段给用户返回特定语言的网页版本。</li>
</ul>

<p>
如果是 <code>GET</code> 请求，那么该 HTTP 请求只有 HTTP Header，没有 HTTP Body。如果是 <code>POST</code> 请求，那么该 HTTP 请求带有 Body，以一个空行分隔。一个典型的带 Body 的 HTTP 请求如下：
</p>

<pre class="example">
POST /login HTTP/1.1
Host: www.example.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

username=hello&amp;password=123456
</pre>

<p>
<code>POST</code> 请求通常要设置 <code>Content-Type</code> 表示 Body 的类型， <code>Content-Length</code> 表示 Body 的长度，这样服务器就可以根据请求的 Header 和 Body 做出正确的响应。
</p>

<essay>
请求的 Header 就是给服务器用的。
</essay>

<p>
此外， <code>GET</code> 请求的参数必须附加在 URL 上，并以 URLEncoded 方式编码，例如： <code>http://www.example.com/?a=1&amp;b=K%26R</code> ，参数分别是 <code>a=1</code> 和 <code>b=K&amp;R</code> 。
</p>

<p>
因为 URL 的长度限制， <code>GET</code> 请求的参数不能太多，而 <code>POST</code> 请求的参数就没有长度限制，因为 <code>POST</code> 请求的参数必须放到 Body 中。并且， <code>POST</code> 请求的参数不一定是 URL 编码，可以按任意格式编码，只需要在 <code>Content-Type</code> 中正确设置即可。
</p>

<p>
常见的发送 JSON 的 <code>POST</code> 请求如下：
</p>

<pre class="example">
POST /login HTTP/1.1
Content-Type: application/json
Content-Length: 38

{"username": "bob", "password": "123456"}
</pre>
</div>
</div>

<div id="outline-container-org769a935" class="outline-3">
<h3 id="org769a935">HTTP 响应</h3>
<div class="outline-text-3" id="text-org769a935">
<p>
<b>HTTP 响应也是由 Header 和 Body 两部分组成</b> ，一个典型的 HTTP 响应如下：
</p>

<pre class="example">
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 133251

&lt;!DOCTYPE html&gt;
&lt;html&gt;&lt;body&gt;
&lt;h1&gt;Hello&lt;/h1&gt;
...
</pre>

<p>
响应的第一行总是 <code>HTTP版本 响应代码 响应说明</code> ，例如， <code>HTTP/1.1 200 OK</code> 表示版本是 <code>HTTP/1.1</code> ，响应代码是 <code>200</code> ，响应说明是 <code>OK</code> 。
</p>

<p>
<b>客户端只依赖响应代码判断 HTTP 响应是否成功</b> ，HTTP 有固定的响应代码：
</p>
<ul class="org-ul">
<li><code>1xx</code> ：表示一个提示性响应，例如 <code>101</code> 表示将切换协议，常见于 WebSocket 连接；</li>
<li><code>2xx</code> ：表示一个成功的响应，例如 <code>200</code> 表示成功， <code>206</code> 表示只发送了部分内容；</li>
<li><code>3xx</code> ：表示一个重定向的响应，例如 <code>301</code> 表示永久重写向， <code>303</code> 表示客户端应该按指定路径重新发送请求；</li>
<li><code>4xx</code> ：表示一个因为客户端问题导致的错误响应，例如 <code>400</code> 表示因为 <code>Content-Type</code> 等各种原因导致的无效请求， <code>404</code> 表示指定的路径不存在；</li>
<li><code>5xx</code> ：表示一个因为服务器问题导致的错误响应，例如 <code>500</code> 表示服务器内部故障， <code>503</code> 表示服务器暂时无法响应。</li>
</ul>

<p>
当浏览器收到第一个 HTTP 响应后，它解析 HTML 后，又会发送一系列 HTTP 请求，例如， <code>GET /logo.jpg HTTP/1.1</code> 请求一个图片，服务器响应请求后，会直接把二进制内容的图片发送给浏览器：
</p>

<pre class="example">
HTTP/1.1 200 OK
Content-Type: image/jpeg
Content-Length: 18391

????JFIFHH??XExifMM?i&amp;??X?...(二进制的JPEG图片)
</pre>

<p>
因此，服务器总是被动地接收客户端的一个 HTTP 请求，然后响应它。客户端根据需要发送若干个 HTTP 请求。
</p>

<p>
对于最早期的 <code>HTTP/1.0</code> 协议，每次发送一个 HTTP 请求，客户端都需要先创建一个新的 TCP 连接，然后，收到服务器响应后，关闭这个 TCP 连接。由于建立 TCP 连接就比较耗时，因此，为了提高效率， <code>HTTP/1.1</code> 协议允许在一个 TCP 连接中反复“发送-响应”，这样就能大大提高效率。
</p>

<img
src="/images/java/java-19.png"
width=""
height=""
style=""
title=""
/>

<p>
因为 HTTP 协议是一个请求-响应协议，客户端在发送了一个 HTTP 请求后，必须等待服务器响应后，才能发送下一个请求，这样一来，如果某个响应太慢，它就会堵住后面的请求。
</p>

<essay>
TCP 连接是能复用了，等待响应又成问题了……
</essay>

<p>
所以，为了进一步提速， <code>HTTP/2.0</code> 允许客户端在没有收到响应的时候，发送多个 HTTP 请求，服务器返回响应的时候，不一定按顺序返回，只要双方能识别出哪个响应对应哪个请求，就可以做到并行发送和接收：
</p>

<img
src="/images/java/java-20.png"
width=""
height=""
style=""
title=""
/>

<essay>
有了问题，也就有同时产生了解决问题的可能。
</essay>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2020-10-05 Mon 09:53</p>
<p class="author">Author: Jack Liu</p>
<p class="date">Created: 2020-10-05 Mon 17:44</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
