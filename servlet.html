<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2020-10-07 Wed 18:48 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Servlet 是什么</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Jack Liu">
<link rel="shortcut icon" href="/images/rose-red.png" type="image/x-icon" />
<link rel="stylesheet" href="/css/animate.min.css" />
<link rel="stylesheet" href="/css/all.min.css" />
<link rel="stylesheet" type="text/css" href="/css/style.css" />
<script src="/js/jquery.min.js"></script>
<script src="/js/darkreader.js"></script>
<script src="/user.config.js"></script>
<script src="/js/main.js"></script>
</head>
<body>
<div id="content">
<h1 class="title">Servlet 是什么</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org00ec675">Web 开发</a></li>
<li><a href="#orgda162d3">Servlet 入门</a></li>
<li><a href="#org993d8b2">Servlet 开发</a></li>
<li><a href="#org4f2e6b6">Servlet 是什么</a></li>
<li><a href="#org8caff6a">Servlet 相关的接口和类</a></li>
<li><a href="#org863af58">Servlet 生命周期</a></li>
<li><a href="#org1d7c57f">第一个 Servlet 程序</a></li>
<li><a href="#org4a30b02">Servlet 虚拟路径映射的配置</a>
<ul>
<li><a href="#org9ff7fb0">Servlet 的多重映射</a></li>
<li><a href="#org6bcd272">Servlet 映射路径中使用通配符</a></li>
<li><a href="#orgfa95d30">默认 Servlet</a></li>
</ul>
</li>
<li><a href="#orgf0264fb">ServletConfig 和 ServletContext 接口</a>
<ul>
<li><a href="#orgf36789b">ServletConfig 接口</a></li>
<li><a href="#org4b38eb9">ServletContext 接口</a></li>
</ul>
</li>
<li><a href="#org5573327">Servlet 处理用户请求的完整流程</a></li>
<li><a href="#org6fa569b">HttpServletRequest</a>
<ul>
<li><a href="#org2e6eb50">获取请求行信息的相关方法</a></li>
<li><a href="#org6b85d99">获取请求消息头的相关方法</a></li>
<li><a href="#org9212f46"><span class="todo TODO">TODO</span> Servlet 获取 form 表单数据</a></li>
<li><a href="#org430f353">RequestDispatcher 实现请求转发</a></li>
</ul>
</li>
<li><a href="#orge72f188">HttpServletResponse</a>
<ul>
<li><a href="#org2312f82">发送状态码相关的方法</a></li>
<li><a href="#orgdb6e6ac">发送响应消息头相关的方法</a></li>
<li><a href="#orgad43dd1">发送响应消息体相关的方法</a></li>
<li><a href="#orga6b9181">sendRedirect() 实现重写向</a></li>
</ul>
</li>
<li><a href="#orgebe1723">request/response 中文乱码问题</a>
<ul>
<li><a href="#orge56bbcf">request 中文乱码问题以及解决方案</a></li>
<li><a href="#org1709055">response中文乱码问题以及解决方案</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org00ec675" class="outline-2">
<h2 id="org00ec675">Web 开发<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup></h2>
<div class="outline-text-2" id="text-org00ec675">
<p>
JavaEE 是什么？它并不是一个软件产品，更多的是一种软件架构和设计思想，它是在 JavaSE 的基础上，开发的一系列基于服务的组件、API 标准和通用架构。
</p>

<p>
JavaEE 最核心的组件就是基于 Servlet 标准的 Web 服务器，开发者编写的应用程序是基于 Servlet API 并运行在 Web 服务器内部的：
</p>

<img
src="/images/java/java-29.png"
width=""
height=""
style="float: right; margin-left: 16px;"
title=""
/>

<p>
此外，JavaEE 还有一系列的技术标准，目前最流行的基于 Spring 的轻量级 JavaEE 开发架构，使用最广泛的是 Servlet 和 JMS（Java Message Service，消息服务），以及一系列开源组件。
</p>

<p>
我们访问网站，使用 App 时，都是基于 Web 这种 Browser/Server 模式，简称 BS 架构，它的特点是，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取 Web 页面，并把页面展示给用户即可。
</p>

<p>
在 Web 应用中，浏览器请求一个 URL ，服务器就把生成的 HTML 网页发送给浏览器，而浏览器和服务器之间的传输协议是 HTTP ，HTTP 协议是一个基于 TCP 协议上的请求-响应协议。
</p>

<p>
所为 <span class="underline">HTTP 编程</span> 是以客户端的身份去请求服务器资源，现在，我们需要以服务器的身份响应客户端请求，编写服务器程序来处理客户端请求通常就称之为 <span class="underline">Web 开发</span> 。
</p>

<p>
<b>那么，如何编写一个 HTTP Server 呢？</b>
</p>

<p>
一个 HTTP Server 本质上是一个 TCP 服务器，我们先用 TCP 编程的多线程实现一个服务器框架：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #F92672;">public</span> <span style="color: #F92672;">class</span> <span style="color: #66D9EF;">Server</span> <span style="color: #AE81FF;">{</span>
<span class="linenr"> 2: </span>    <span style="color: #F92672;">public</span> <span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">main</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">String</span><span style="color: #A6E22E;">[]</span> <span style="color: #FD971F;">args</span><span style="color: #66D9EF;">)</span> <span style="color: #F92672;">throws</span> <span style="color: #66D9EF;">IOException</span> <span style="color: #66D9EF;">{</span>
<span class="linenr"> 3: </span>        <span style="color: #66D9EF;">ServerSocket</span> <span style="color: #FD971F;">ss</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">ServerSocket</span><span style="color: #A6E22E;">(</span>8080<span style="color: #A6E22E;">)</span>; <span style="color: #75715E;">// </span><span style="color: #75715E;">&#30417;&#21548;&#25351;&#23450;&#31471;&#21475;</span>
<span class="linenr"> 4: </span>        System.out.println<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"Server is running..."</span><span style="color: #A6E22E;">)</span>;
<span class="linenr"> 5: </span>        <span style="color: #F92672;">for</span> <span style="color: #A6E22E;">(</span>;;<span style="color: #A6E22E;">)</span> <span style="color: #A6E22E;">{</span>
<span class="linenr"> 6: </span>            <span style="color: #66D9EF;">Socket</span> <span style="color: #FD971F;">sock</span> = ss.accept<span style="color: #E6DB74;">()</span>;
<span class="linenr"> 7: </span>            System.out.println<span style="color: #E6DB74;">(</span><span style="color: #E6DB74;">"Connected from "</span> + sock.getRemoteSocketAddress<span style="color: #FD971F;">()</span><span style="color: #E6DB74;">)</span>;
<span class="linenr"> 8: </span>            <span style="color: #66D9EF;">Thread</span> <span style="color: #FD971F;">t</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">Handler</span><span style="color: #E6DB74;">(</span>sock<span style="color: #E6DB74;">)</span>;
<span class="linenr"> 9: </span>            t.start<span style="color: #E6DB74;">()</span>;
<span class="linenr">10: </span>        <span style="color: #A6E22E;">}</span>
<span class="linenr">11: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">12: </span><span style="color: #AE81FF;">}</span>
<span class="linenr">13: </span>
<span class="linenr">14: </span><span style="color: #F92672;">class</span> <span style="color: #66D9EF;">Handler</span> <span style="color: #F92672;">extends</span> <span style="color: #66D9EF;">Thread</span> <span style="color: #AE81FF;">{</span>
<span class="linenr">15: </span>    <span style="color: #66D9EF;">Socket</span> <span style="color: #FD971F;">sock</span>;
<span class="linenr">16: </span>
<span class="linenr">17: </span>    <span style="color: #F92672;">public</span> <span style="color: #A6E22E;">Handler</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">Socket</span> <span style="color: #FD971F;">sock</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr">18: </span>        <span style="color: #F92672;">this</span>.sock = sock;
<span class="linenr">19: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">20: </span>
<span class="linenr">21: </span>    <span style="color: #F92672;">public</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">run</span><span style="color: #66D9EF;">()</span> <span style="color: #66D9EF;">{</span>
<span class="linenr">22: </span>        <span style="color: #F92672;">try</span> <span style="color: #A6E22E;">(</span><span style="color: #66D9EF;">InputStream</span> <span style="color: #FD971F;">input</span> = <span style="color: #F92672;">this</span>.sock.getInputStream<span style="color: #E6DB74;">()</span><span style="color: #A6E22E;">)</span> <span style="color: #A6E22E;">{</span>
<span class="linenr">23: </span>            <span style="color: #F92672;">try</span> <span style="color: #E6DB74;">(</span><span style="color: #66D9EF;">OutputStream</span> <span style="color: #FD971F;">output</span> = <span style="color: #F92672;">this</span>.sock.getOutputStream<span style="color: #FD971F;">()</span><span style="color: #E6DB74;">)</span> <span style="color: #E6DB74;">{</span>
<span class="linenr">24: </span>                handle<span style="color: #FD971F;">(</span>input, output<span style="color: #FD971F;">)</span>;
<span class="linenr">25: </span>            <span style="color: #E6DB74;">}</span>
<span class="linenr">26: </span>        <span style="color: #A6E22E;">}</span> <span style="color: #F92672;">catch</span> <span style="color: #A6E22E;">(</span><span style="color: #66D9EF;">Exception</span> <span style="color: #FD971F;">e</span><span style="color: #A6E22E;">)</span> <span style="color: #A6E22E;">{</span>
<span class="linenr">27: </span>            <span style="color: #F92672;">try</span> <span style="color: #E6DB74;">{</span>
<span class="linenr">28: </span>                <span style="color: #F92672;">this</span>.sock.close<span style="color: #FD971F;">()</span>;
<span class="linenr">29: </span>            <span style="color: #E6DB74;">}</span> <span style="color: #F92672;">catch</span> <span style="color: #E6DB74;">(</span><span style="color: #66D9EF;">IOException</span> <span style="color: #FD971F;">ioe</span><span style="color: #E6DB74;">)</span> <span style="color: #E6DB74;">{</span>
<span class="linenr">30: </span>
<span class="linenr">31: </span>            <span style="color: #E6DB74;">}</span>
<span class="linenr">32: </span>            System.out.println<span style="color: #E6DB74;">(</span><span style="color: #E6DB74;">"Client disconnected."</span><span style="color: #E6DB74;">)</span>;
<span class="linenr">33: </span>        <span style="color: #A6E22E;">}</span>
<span class="linenr">34: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">35: </span>
<span class="linenr">36: </span>    <span style="color: #F92672;">private</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">handle</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">InputStream</span> <span style="color: #FD971F;">input</span>, <span style="color: #66D9EF;">OutputStream</span> <span style="color: #FD971F;">output</span><span style="color: #66D9EF;">)</span> <span style="color: #F92672;">throws</span> <span style="color: #66D9EF;">IOException</span> <span style="color: #66D9EF;">{</span>
<span class="linenr">37: </span>        <span style="color: #66D9EF;">var</span> <span style="color: #FD971F;">reader</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">BufferedReader</span><span style="color: #A6E22E;">(</span><span style="color: #F92672;">new</span> <span style="color: #66D9EF;">InputStreamReader</span><span style="color: #E6DB74;">(</span>input, <span style="color: #AE81FF;">StrandardCharsets</span>.UTF_8<span style="color: #E6DB74;">)</span><span style="color: #A6E22E;">)</span>;
<span class="linenr">38: </span>        <span style="color: #66D9EF;">var</span> <span style="color: #FD971F;">writer</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">BufferedWriter</span><span style="color: #A6E22E;">(</span><span style="color: #F92672;">new</span> <span style="color: #66D9EF;">OutputStreamWriter</span><span style="color: #E6DB74;">(</span>output, <span style="color: #AE81FF;">StrandardCharsets</span>.UTF_8<span style="color: #E6DB74;">)</span><span style="color: #A6E22E;">)</span>;
<span class="linenr">39: </span>        <span style="color: #75715E;">// </span><span style="color: #75715E;">TODO: &#22788;&#29702; HTTP &#35831;&#27714;</span>
<span class="linenr">40: </span>        <span style="color: #75715E;">// </span><span style="color: #75715E;">...</span>
<span class="linenr">41: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">42: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
只需要在 <code>handle()</code> 方法中，用 Reader 读取 HTTP 请求，用 Writer 发送 HTTP 响应，即可实现一个最简单的 HTTP 服务器。编写代码如下：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #F92672;">private</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">handle</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">InputStream</span> <span style="color: #FD971F;">input</span>, <span style="color: #66D9EF;">OutputStream</span> <span style="color: #FD971F;">output</span><span style="color: #AE81FF;">)</span> <span style="color: #F92672;">throws</span> <span style="color: #66D9EF;">IOException</span> <span style="color: #AE81FF;">{</span>
<span class="linenr"> 2: </span>    System.out.println<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">"Process new http request..."</span><span style="color: #66D9EF;">)</span>;
<span class="linenr"> 3: </span>    <span style="color: #66D9EF;">var</span> <span style="color: #FD971F;">reader</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">BufferedReader</span><span style="color: #66D9EF;">(</span><span style="color: #F92672;">new</span> <span style="color: #66D9EF;">InputStreamReader</span><span style="color: #A6E22E;">(</span>input, <span style="color: #AE81FF;">StandardCharsets</span>.UTF_8<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span>;
<span class="linenr"> 4: </span>    <span style="color: #66D9EF;">var</span> <span style="color: #FD971F;">writer</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">BufferedWriter</span><span style="color: #66D9EF;">(</span><span style="color: #F92672;">new</span> <span style="color: #66D9EF;">OutputStreamWriter</span><span style="color: #A6E22E;">(</span>output, <span style="color: #AE81FF;">StandardCharsets</span>.UTF_8<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span>;
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>    <span style="color: #75715E;">// </span><span style="color: #75715E;">&#35835;&#21462; HTTP &#35831;&#27714;</span>
<span class="linenr"> 7: </span>    <span style="color: #66D9EF;">boolean</span> <span style="color: #FD971F;">requestOk</span> = <span style="color: #AE81FF;">false</span>;
<span class="linenr"> 8: </span>    <span style="color: #66D9EF;">String</span> <span style="color: #FD971F;">first</span> = reader.readLine<span style="color: #66D9EF;">()</span>;
<span class="linenr"> 9: </span>    <span style="color: #F92672;">if</span> <span style="color: #66D9EF;">(</span>first.startsWith<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"GET / HTTP/1."</span><span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr">10: </span>        requestOk = <span style="color: #AE81FF;">true</span>;
<span class="linenr">11: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">12: </span>    <span style="color: #F92672;">for</span> <span style="color: #66D9EF;">(</span>;;<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr">13: </span>        <span style="color: #66D9EF;">String</span> <span style="color: #FD971F;">header</span> = reader.readLine<span style="color: #A6E22E;">()</span>;
<span class="linenr">14: </span>        <span style="color: #F92672;">if</span> <span style="color: #A6E22E;">(</span>header.isEmpty<span style="color: #E6DB74;">()</span><span style="color: #A6E22E;">)</span> <span style="color: #A6E22E;">{</span> <span style="color: #75715E;">// </span><span style="color: #75715E;">&#35835;&#21462;&#21040;&#31354;&#34892;&#26102;&#65292;HTTP Header &#35835;&#21462;&#23436;&#27605;</span>
<span class="linenr">15: </span>            <span style="color: #F92672;">break</span>;
<span class="linenr">16: </span>        <span style="color: #A6E22E;">}</span>
<span class="linenr">17: </span>        System.out.println<span style="color: #A6E22E;">(</span>header<span style="color: #A6E22E;">)</span>;
<span class="linenr">18: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">19: </span>    System.out.println<span style="color: #66D9EF;">(</span>requestOk ? <span style="color: #E6DB74;">"Response OK"</span> : <span style="color: #E6DB74;">"Response Error"</span><span style="color: #66D9EF;">)</span>;
<span class="linenr">20: </span>
<span class="linenr">21: </span>    <span style="color: #F92672;">if</span> <span style="color: #66D9EF;">(</span><span style="color: #E6DB74; font-weight: bold;">!</span>requestOk<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">{</span>
<span class="linenr">22: </span>        <span style="color: #75715E;">// </span><span style="color: #75715E;">&#21457;&#36865;&#38169;&#35823;&#21709;&#24212;</span>
<span class="linenr">23: </span>        writer.write<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"HTTP/1.0 404 Not Found\r\n"</span><span style="color: #A6E22E;">)</span>;
<span class="linenr">24: </span>        writer.write<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"Content-Length: 0\r\n"</span><span style="color: #A6E22E;">)</span>;
<span class="linenr">25: </span>        writer.write<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"\r\n"</span><span style="color: #A6E22E;">)</span>;
<span class="linenr">26: </span>        writer.flush<span style="color: #A6E22E;">()</span>;
<span class="linenr">27: </span>    <span style="color: #66D9EF;">}</span> <span style="color: #F92672;">else</span> <span style="color: #66D9EF;">{</span>
<span class="linenr">28: </span>        <span style="color: #75715E;">// </span><span style="color: #75715E;">&#21457;&#36865;&#25104;&#21151;&#21709;&#24212;</span>
<span class="linenr">29: </span>        <span style="color: #66D9EF;">String</span> <span style="color: #FD971F;">data</span> = <span style="color: #E6DB74;">"&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello, world!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;"</span>;
<span class="linenr">30: </span>        <span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">length</span> = data.getBytes<span style="color: #A6E22E;">(</span><span style="color: #AE81FF;">StandardCharsets</span>.UTF_8<span style="color: #A6E22E;">)</span>.length;
<span class="linenr">31: </span>        writer.write<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"HTTP/1.0 200 OK\r\n"</span><span style="color: #A6E22E;">)</span>;
<span class="linenr">32: </span>        writer.write<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"Connection: close\r\n"</span><span style="color: #A6E22E;">)</span>;
<span class="linenr">33: </span>        writer.write<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"Content-Type: text/html\r\n"</span><span style="color: #A6E22E;">)</span>;
<span class="linenr">34: </span>        writer.write<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"Content-Length: "</span> + length + <span style="color: #E6DB74;">"\r\n"</span><span style="color: #A6E22E;">)</span>;
<span class="linenr">35: </span>        writer.write<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"\r\n"</span><span style="color: #A6E22E;">)</span>;   <span style="color: #75715E;">// </span><span style="color: #75715E;">&#31354;&#34892;&#26631;&#35782; Header &#21644; Body &#30340;&#20998;&#38548;</span>
<span class="linenr">36: </span>        writer.write<span style="color: #A6E22E;">(</span>data<span style="color: #A6E22E;">)</span>;
<span class="linenr">37: </span>        writer.flush<span style="color: #A6E22E;">()</span>;
<span class="linenr">38: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">39: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
这里的核心代码是，先读取 HTTP 请求，这里我们只处理 <code>GET /</code> 的请求。当读取到空行时，表示已读到连续两个 <code>\r\n</code> ，说明请求结束，可以发送响应。发送响应的时候，首先发送响应代码 <code>HTTP/1.0 200 OK</code> 表示一个成功的 <code>200</code> 响应，使用 <code>HTTP/1.0</code> 协议，然后，依次发送 Header ，发送完 Header 后，再发送一个空行标识 Header 结束，紧接着发送 HTTP Body，在浏览器输入 <code>http://local.liaoxuefent.com/8080/</code> 就可以看到响应页面：
</p>

<img
src="/images/java/java-30.jpg"
width=""
height=""
style=""
title=""
/>

<p>
HTTP 目前有多个版本， <code>1.0</code> 是早期版本，浏览器每次建立 TCP 连接后，只发送一个 HTTP 请求并接收一个 HTTP 响应，然后就关闭 TCP 连接。
</p>

<p>
由于创建 TCP 连接本身就需要消耗一定的时间，因此，HTTP 1.1 允许浏览器和服务器在同一个 TCP 连接上反复发送、接收多个 HTTP 请求和响应，这样就大大提高了传输效率。
</p>

<p>
然而，HTTP 协议是一个请求-响应协议，它都是发送一个请求，然后接收一个响应。能不能一次性发送多个请求，然后再接收多个响应呢？
</p>

<p>
可以的！
</p>

<p>
HTTP 2.0 可以支持浏览器同时发出多个请求，但每个请求需要唯一标识，服务器可以不按请求的顺序返回多个响应，由浏览器自己把收到的响应和请求对应起来。可见，HTTP 2.0 进一步提高了效率，因为浏览器发出一个请求后，不必等待响应，就可以继续发下一个请求。
</p>

<p>
HTTP 3.0 为了进一步提高速度，将抛弃 TCP 协议，改为使用无需创建连接的 UDP 协议，目前仍然处于实验阶段。
</p>

<essay>
技术的进步是无止境的……
</essay>
</div>
</div>

<div id="outline-container-orgda162d3" class="outline-2">
<h2 id="orgda162d3">Servlet 入门</h2>
<div class="outline-text-2" id="text-orgda162d3">
<p>
在上一节中，可见，编写 HTTP 服务器其实是非常简单的，只需要先编写基于多线程的 TCP 服务，然后在一个 TCP 连接中读取 HTTP 请求，发送 HTTP 响应即可。
</p>

<p>
但是，要编写一个完善的 HTTP 服务器，以 HTTP/1.1 为例，需要考虑的包括：
</p>
<ul class="org-ul">
<li>识别正确和错误的 HTTP 请求；</li>
<li>识别正确和错误的 HTTP 头；</li>
<li>利用 TCP 连接；</li>
<li>利用线程；</li>
<li>IO 异常处理；</li>
<li>&#x2026;</li>
</ul>

<p>
BUT 这些基础工作需要耗费大量的时间，并且经过长时间测试才能稳定运行， <b>太低效了，太难了</b> 。
</p>

<p>
幸运的是，在 JavaEE 平台上，处理 TCP 连接，解析 HTTP 协议这些底层工作统统扔给现成的 Web 服务器去做，我们只需要把自己的应用程序跑在 Web 服务器上。
</p>

<essay>
交给可靠的机制去运行，省力又省心。
</essay>

<p>
JavaEE 是如何实现这一点的呢？
</p>

<p>
JavaEE 提供了 Servlet API，我们使用 Servlet API 编写自己的 Servlet 来处理 HTTP 请求，Web 服务器实现 Servlet API 接口，实现底层功能：
</p>

<img
src="/images/java/java-31.png"
width=""
height=""
style=""
title=""
/>

<p>
下面我们来实现一个最简单的 Servlet ：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #75715E;">// </span><span style="color: #75715E;">WebServlet &#27880;&#35299;&#34920;&#31034;&#36825;&#26159;&#19968;&#20010; Servlet &#65292;&#24182;&#26144;&#23556;&#21040;&#22320;&#22336; `/` &#65306;</span>
<span class="linenr"> 2: </span><span style="color: #AE81FF;">@WebServlet</span><span style="color: #AE81FF;">(</span>urlPatterns = <span style="color: #E6DB74;">"/"</span><span style="color: #AE81FF;">)</span>
<span class="linenr"> 3: </span><span style="color: #F92672;">public</span> <span style="color: #F92672;">class</span> <span style="color: #66D9EF;">HelloServlet</span> <span style="color: #F92672;">extends</span> <span style="color: #66D9EF;">HttpServlet</span> <span style="color: #AE81FF;">{</span>
<span class="linenr"> 4: </span>    <span style="color: #F92672;">protected</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">doGet</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">HttpServletRequest</span> <span style="color: #FD971F;">req</span>, <span style="color: #66D9EF;">HttpServletResponse</span> <span style="color: #FD971F;">resp</span><span style="color: #66D9EF;">)</span>
<span class="linenr"> 5: </span>        <span style="color: #F92672;">throws</span> <span style="color: #66D9EF;">ServletException</span>, <span style="color: #66D9EF;">IOException</span> <span style="color: #66D9EF;">{</span>
<span class="linenr"> 6: </span>        <span style="color: #75715E;">// </span><span style="color: #75715E;">&#35774;&#32622;&#21709;&#24212;&#31867;&#22411;&#65306;</span>
<span class="linenr"> 7: </span>        resp.setContentType<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"text/html"</span><span style="color: #A6E22E;">)</span>;
<span class="linenr"> 8: </span>        <span style="color: #75715E;">// </span><span style="color: #75715E;">&#33719;&#21462;&#36755;&#20986;&#27969;&#65306;</span>
<span class="linenr"> 9: </span>        <span style="color: #66D9EF;">PrintWriter</span> <span style="color: #FD971F;">pw</span> = resp.getWriter<span style="color: #A6E22E;">()</span>;
<span class="linenr">10: </span>        <span style="color: #75715E;">// </span><span style="color: #75715E;">&#20889;&#20837;&#21709;&#24212;&#65306;</span>
<span class="linenr">11: </span>        pw.write<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"&lt;h1&gt;Hello, world!&lt;/h1&gt;"</span><span style="color: #A6E22E;">)</span>;
<span class="linenr">12: </span>        <span style="color: #75715E;">// </span><span style="color: #75715E;">&#26368;&#21518;&#19981;&#35201;&#24536;&#35760; flush &#24378;&#21046;&#36755;&#20986;&#65306;</span>
<span class="linenr">13: </span>        pw.flush<span style="color: #A6E22E;">()</span>;
<span class="linenr">14: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">15: </span><span style="color: #AE81FF;">}</span>
<span class="linenr">16: </span>
</pre>
</div>

<p>
<b>一个 Servlet 总是继承自 <code>HttpServlet</code> ，然后覆写 <code>doGet()</code> 或 <code>doPost()</code> 方法</b> 。
</p>

<p>
注意到 <code>doGet()</code> 方法传入了 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 两个对象，分别代表 HTTP 请求和响应。
</p>

<p>
我们使用 Servlet API 时，并不直接与底层 TCP 交互，也不需要解析 HTTP 协议，因为 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 就已经封装好了请求和响应。以发送响应为例，我们只需要设置正确的响应类型，然后获取 <code>PrintWriter</code> ，写入响应即可。
</p>

<p>
<b>Servlet API 是什么？</b>
</p>

<p>
Servlet API 是一个 jar 包，我们需要通过 Maven 来引入它，才能正常编译。通过 Maven 构建后会得到一个 <code>.war</code> 格式的文件，那么， <b>如何运行这个 <code>war</code> 文件呢</b> ？
</p>

<p>
普通的 Java 程序是通过启动 JVM ，然后执行 <code>main()</code> 方法开始运行。但是 Web 应用程序有所不同，我们无法直接运行 <code>war</code> 文件，必须先启动 Web 服务器，再由 Web 服务器加载我们编写的 HelloServlet ，这样就可以让我们编写的 HelloServlet 处理浏览器发送的请求。
</p>

<p>
<b>那么，Servlet API是谁提供的呢？</b>
</p>

<p>
是由支持 Servlet API 的 Web 服务器提供的！常用的服务器有：
</p>
<ul class="org-ul">
<li>Tomcat ：由 Apache 开发的开源免费服务器；</li>
<li>Jetty ：由 Eclipse 开发的开源免费服务器；</li>
<li>GlassFish ：一个开源的全功能 JavaEE 服务器；</li>
<li>WebLogic ：Oracle 的商用服务器；</li>
<li>WebSphere ：IBM 的调用服务器。</li>
</ul>

<p>
无论使用哪个服务器，只要它支持相同版本的 Servlet API ，我们在引版本上开发构建的 <code>war</code> 包都可以在上面运行。
</p>

<p>
我们通常选用最广泛的开源免费的 Tomcat 服务器。
</p>

<p>
实际上，类似 Tomcat 这样的服务器也是 Java 编写的，启动 Tomcat 服务器实际上是启动 Java 虚拟机，执行 Tomcat 的 <code>main()</code> 方法，然后由 Tomcat 负责加载我们的 <code>.war</code> 文件，并创建一个我们编写的 HelloServlet 实例，最后以多线程的模式来处理 HTTP 请求。例如，Tomcat 服务器收到的请求路径是 <code>/</code> 时，就转发到 HelloServlet 并传入 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 现个对象。
</p>

<p>
由上可知，我们编写的 Servlet 并不是直接运行，而是由 Web 服务器加载后创建实例运行，所以，类似于 Tomcat 这样的 Web 服务器也称为 <span class="underline">Servlet 容器</span> 。
</p>

<p>
在 Servlet 容器中运行的 Servlet 具有如下特点：
</p>
<ul class="org-ul">
<li>无法在代码中直接通过 new 创建 Servlet 实例，必须由 Servlet 容器自动创建 Servlet 实例；</li>
<li>Servlet 容器只会给每个 Servlet 类创建唯一实例；</li>
<li>Servlet 容器会使用多线程执行 <code>doGet()</code> 或 <code>doPost()</code> 方法。</li>
</ul>

<p>
*注：在 Servlet 中定义的实例变量会被多个线程同时访问，要注意线程安全。正确编写 Servlet ，要清晰理解 Java 的多线程模型，需要同步访问的必须同步。
</p>
</div>
</div>

<div id="outline-container-org993d8b2" class="outline-2">
<h2 id="org993d8b2">Servlet 开发</h2>
<div class="outline-text-2" id="text-org993d8b2">
<p>
通常，一个完整的 Web 应用程序的开发流程如下：
</p>
<ol class="org-ol">
<li>编写 Servlet ；</li>
<li>打包为 war 文件；</li>
<li>复制到 Tomcat 的 webapps 目录下；</li>
<li>启动 Tomcat 。</li>
</ol>

<p>
这个过程同样很繁琐（开发者都是“懒虫”啦），而且如果我们想在 IDE 中断点调试，还需要打开 Tomcat 的远程调试端口并且连接上去。
</p>

<p>
但是，许多初学者经常卡在如何在 IDE 中启动 Tomcat 并加载 webapp，更不要说断点调试了……
</p>

<p>
Tomcat 实际上也是一个 Java 程序，我们看看 Tomcat 的启动流程：
</p>
<ol class="org-ol">
<li>启动 JVM 并执行 Tomcat 的 <code>main()</code> 方法；</li>
<li>加载 <code>.war</code> 文件并初始化 Servlet ；</li>
<li>正常服务。</li>
</ol>

<p>
那么，启动 Tomcat 无非就是设置好 classpath 并执行 Tomcat 某个 jar 包的 <code>main()</code> 方法，我们完全可以把 Tomcat 的 jar 包全部引入进来，然后自己编写一个 <code>main()</code> 方法，先启动 Tomcat ，会后让它加载我们的 webapp 就可以了。
</p>

<p>
我们新建一个 <code>web-servlet-embedded</code> 工程，编写 <code>pom.xml</code> 如下：
</p>

<div class="org-src-container">
<pre class="src src-xml"><span class="linenr"> 1: </span>&lt;<span style="color: #A6E22E;">project</span> <span style="color: #F92672;">xmlns</span>=<span style="color: #E6DB74;">"http://maven.apache.org/POM/4.0.0"</span>
<span class="linenr"> 2: </span>         <span style="color: #F92672;">xmlns</span>:<span style="color: #FD971F;">xsi</span>=<span style="color: #E6DB74;">"http://www.w3.org/2001/XMLSchema-instance"</span>
<span class="linenr"> 3: </span>         <span style="color: #F92672;">xsi</span>:<span style="color: #FD971F;">schemaLocation</span>=<span style="color: #E6DB74;">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;
<span class="linenr"> 4: </span>         &lt;<span style="color: #A6E22E;">modelVersion</span>&gt;4.0.0&lt;/<span style="color: #A6E22E;">modelVersion</span>&gt;
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>         &lt;<span style="color: #A6E22E;">groupId</span>&gt;com.itranswarp.leanjava&lt;/<span style="color: #A6E22E;">groupId</span>&gt;
<span class="linenr"> 7: </span>         &lt;<span style="color: #A6E22E;">artifactId</span>&gt;web-servlet-embedded&lt;/<span style="color: #A6E22E;">artifactId</span>&gt;
<span class="linenr"> 8: </span>         &lt;<span style="color: #A6E22E;">version</span>&gt;1.0-SNAPSHOT&lt;/<span style="color: #A6E22E;">version</span>&gt;
<span class="linenr"> 9: </span>         &lt;<span style="color: #A6E22E;">packaging</span>&gt;war&lt;/<span style="color: #A6E22E;">packaging</span>&gt;
<span class="linenr">10: </span>
<span class="linenr">11: </span>         &lt;<span style="color: #A6E22E;">properties</span>&gt;
<span class="linenr">12: </span>           &lt;<span style="color: #A6E22E;">project.build.sourceEncoding</span>&gt;UTF-8&lt;/<span style="color: #A6E22E;">project.build.sourceEncoding</span>&gt;
<span class="linenr">13: </span>           &lt;<span style="color: #A6E22E;">project.reporting.outputEncoding</span>&gt;UTF-8&lt;/<span style="color: #A6E22E;">project.reporting.outputEncoding</span>&gt;
<span class="linenr">14: </span>           &lt;<span style="color: #A6E22E;">maven.compiler.source</span>&gt;11&lt;/<span style="color: #A6E22E;">maven.compiler.source</span>&gt;
<span class="linenr">15: </span>           &lt;<span style="color: #A6E22E;">maven.compiler.target</span>&gt;11&lt;/<span style="color: #A6E22E;">maven.compiler.target</span>&gt;
<span class="linenr">16: </span>           &lt;<span style="color: #A6E22E;">java.version</span>&gt;11&lt;/<span style="color: #A6E22E;">java.version</span>&gt;
<span class="linenr">17: </span>           &lt;<span style="color: #A6E22E;">tomcat.version</span>&gt;9.0.26&lt;/<span style="color: #A6E22E;">tomcat.version</span>&gt;
<span class="linenr">18: </span>         &lt;/<span style="color: #A6E22E;">properties</span>&gt;
<span class="linenr">19: </span>
<span class="linenr">20: </span>         &lt;<span style="color: #A6E22E;">dependencies</span>&gt;
<span class="linenr">21: </span>           &lt;<span style="color: #A6E22E;">dependency</span>&gt;
<span class="linenr">22: </span>             &lt;<span style="color: #A6E22E;">groupId</span>&gt;org.apache.tomcat.embed&lt;/<span style="color: #A6E22E;">groupId</span>&gt;
<span class="linenr">23: </span>             &lt;<span style="color: #A6E22E;">artifactId</span>&gt;tomcat-embed-core&lt;/<span style="color: #A6E22E;">artifactId</span>&gt;
<span class="linenr">24: </span>             &lt;<span style="color: #A6E22E;">version</span>&gt;${tomcat.version}&lt;/<span style="color: #A6E22E;">version</span>&gt;
<span class="linenr">25: </span>             &lt;<span style="color: #A6E22E;">scope</span>&gt;provided&lt;/<span style="color: #A6E22E;">scope</span>&gt;
<span class="linenr">26: </span>           &lt;/<span style="color: #A6E22E;">dependency</span>&gt;
<span class="linenr">27: </span>           &lt;<span style="color: #A6E22E;">dependency</span>&gt;
<span class="linenr">28: </span>             &lt;<span style="color: #A6E22E;">groupId</span>&gt;org.apache.tomcat.embed&lt;/<span style="color: #A6E22E;">groupId</span>&gt;
<span class="linenr">29: </span>             &lt;<span style="color: #A6E22E;">artifactId</span>&gt;tomcat-embed-jasper&lt;/<span style="color: #A6E22E;">artifactId</span>&gt;
<span class="linenr">30: </span>             &lt;<span style="color: #A6E22E;">version</span>&gt;${tomcat.version}&lt;/<span style="color: #A6E22E;">version</span>&gt;
<span class="linenr">31: </span>             &lt;<span style="color: #A6E22E;">scope</span>&gt;provided&lt;/<span style="color: #A6E22E;">scope</span>&gt;
<span class="linenr">32: </span>           &lt;/<span style="color: #A6E22E;">dependency</span>&gt;
<span class="linenr">33: </span>         &lt;/<span style="color: #A6E22E;">dependencies</span>&gt;
<span class="linenr">34: </span>&lt;/<span style="color: #A6E22E;">project</span>&gt;
</pre>
</div>

<p>
其中， <code>&lt;packaging&gt;</code> 类型仍然为 <code>war</code> ，引入依赖 <code>tomcat-embed-core</code> 和 <code>tomcat-embed-jasper</code> ，引入的 Tomcat 版本为 <code>&lt;tomcat.version&gt;</code> 为 <code>9.0.26</code> 。
</p>

<p>
不必引入 Servlet API，因为引入 Tomcat 依赖后自动引入了 Servlet API 。因此，我们可以正常编写 Servlet 如下：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #AE81FF;">@WebServlet</span><span style="color: #AE81FF;">(</span>urlPatterns = <span style="color: #E6DB74;">"/"</span><span style="color: #AE81FF;">)</span>
<span class="linenr"> 2: </span><span style="color: #F92672;">public</span> <span style="color: #F92672;">class</span> <span style="color: #66D9EF;">HelloServlet</span> <span style="color: #F92672;">extends</span> <span style="color: #66D9EF;">HttpServlet</span> <span style="color: #AE81FF;">{</span>
<span class="linenr"> 3: </span>    <span style="color: #F92672;">protected</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">doGet</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">HttpServletRequest</span> <span style="color: #FD971F;">req</span>, <span style="color: #66D9EF;">HttpServletResponse</span> <span style="color: #FD971F;">resp</span><span style="color: #66D9EF;">)</span>
<span class="linenr"> 4: </span>        <span style="color: #F92672;">throws</span> <span style="color: #66D9EF;">ServletException</span>, <span style="color: #66D9EF;">IOException</span> <span style="color: #66D9EF;">{</span>
<span class="linenr"> 5: </span>        resp.setContentType<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"text/html"</span><span style="color: #A6E22E;">)</span>;
<span class="linenr"> 6: </span>        <span style="color: #66D9EF;">String</span> <span style="color: #FD971F;">name</span> = req.getParameter<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"name"</span><span style="color: #A6E22E;">)</span>;
<span class="linenr"> 7: </span>        <span style="color: #F92672;">if</span> <span style="color: #A6E22E;">(</span>name == <span style="color: #AE81FF;">null</span><span style="color: #A6E22E;">)</span> <span style="color: #A6E22E;">{</span>
<span class="linenr"> 8: </span>            name = <span style="color: #E6DB74;">"world"</span>;
<span class="linenr"> 9: </span>        <span style="color: #A6E22E;">}</span>
<span class="linenr">10: </span>        <span style="color: #66D9EF;">PrintWriter</span> <span style="color: #FD971F;">pw</span> = resp.getWriter<span style="color: #A6E22E;">()</span>;
<span class="linenr">11: </span>        pw.write<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"&lt;h1&gt;Hello, "</span> + name + <span style="color: #E6DB74;">"&lt;/h1&gt;"</span><span style="color: #A6E22E;">)</span>;
<span class="linenr">12: </span>        pw.flush<span style="color: #A6E22E;">()</span>;
<span class="linenr">13: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">14: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
然后，我们编写一个 <code>main()</code> 方法，启动 Tomcat 服务器：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #F92672;">public</span> <span style="color: #F92672;">class</span> <span style="color: #66D9EF;">Main</span> <span style="color: #AE81FF;">{</span>
<span class="linenr"> 2: </span>    <span style="color: #F92672;">public</span> <span style="color: #F92672;">static</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">main</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">String</span><span style="color: #A6E22E;">[]</span> <span style="color: #FD971F;">args</span><span style="color: #66D9EF;">)</span> <span style="color: #F92672;">throws</span> <span style="color: #66D9EF;">Exception</span> <span style="color: #66D9EF;">{</span>
<span class="linenr"> 3: </span>        <span style="color: #75715E;">// </span><span style="color: #75715E;">&#21551;&#21160; Tomcat &#65306;</span>
<span class="linenr"> 4: </span>        <span style="color: #66D9EF;">Tomcat</span> <span style="color: #FD971F;">tomcat</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">Tomcat</span><span style="color: #A6E22E;">()</span>;
<span class="linenr"> 5: </span>        tomcat.setPort<span style="color: #A6E22E;">(</span>Integer.getInteger<span style="color: #E6DB74;">(</span><span style="color: #E6DB74;">"port"</span>, 8080<span style="color: #E6DB74;">)</span><span style="color: #A6E22E;">)</span>;
<span class="linenr"> 6: </span>        tomcat.getConnectory<span style="color: #A6E22E;">()</span>;
<span class="linenr"> 7: </span>        <span style="color: #75715E;">// </span><span style="color: #75715E;">&#21019;&#24314; webapp &#65306;</span>
<span class="linenr"> 8: </span>        <span style="color: #66D9EF;">Context</span> <span style="color: #FD971F;">ctx</span> = tomcat.addWebApp<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">""</span>, <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">File</span><span style="color: #E6DB74;">(</span><span style="color: #E6DB74;">"src/main/webapp"</span><span style="color: #E6DB74;">)</span>,getAbsolutePath<span style="color: #E6DB74;">()</span><span style="color: #A6E22E;">)</span>;
<span class="linenr"> 9: </span>        <span style="color: #66D9EF;">WebResourceRoot</span> <span style="color: #FD971F;">resources</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">StandardRoot</span><span style="color: #A6E22E;">(</span>ctx<span style="color: #A6E22E;">)</span>;
<span class="linenr">10: </span>        resources.addPreResources<span style="color: #A6E22E;">(</span><span style="color: #F92672;">new</span> <span style="color: #66D9EF;">DirResourceSet</span><span style="color: #E6DB74;">(</span>resources, <span style="color: #E6DB74;">"/WEB-INF/classes"</span>, <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">File</span><span style="color: #FD971F;">(</span><span style="color: #E6DB74;">"target/classes"</span><span style="color: #FD971F;">)</span>.getAbsolutePath<span style="color: #FD971F;">()</span>, <span style="color: #E6DB74;">"/"</span><span style="color: #E6DB74;">)</span><span style="color: #A6E22E;">)</span>;
<span class="linenr">11: </span>        ctx.setResources<span style="color: #A6E22E;">(</span>resources<span style="color: #A6E22E;">)</span>;
<span class="linenr">12: </span>        tomcat.start<span style="color: #A6E22E;">()</span>;
<span class="linenr">13: </span>        tomcat.getServer<span style="color: #A6E22E;">()</span>.await<span style="color: #A6E22E;">()</span>;
<span class="linenr">14: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">15: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
如此，我们直接运行 <code>main()</code> 方法，即可启动嵌入式 Tomcat 服务器，
</p>

<p>
后，通过预设的 <code>tomcat.addWebapp("", new File("src/main/webapp")</code> ，Tomcat 会自动加载当前工程作为根 webapp，可直接在浏览器访问 <a href="http://localhost:8080/%EF%BC%9A">http://localhost:8080/：</a>
</p>

<img
src="/images/java/java-32.png"
width=""
height=""
style=""
title=""
/>

<p>
通过 <code>main()</code> 方法启动 Tomcat 服务器并加载我们自己的 webapp 有如下好处：
</p>
<ol class="org-ol">
<li>启动简单，无需下载 Tomcat 或安装任何 IDE 插件；</li>
<li>高度方便，可在 IDE 中使用断点调试；</li>
<li>使用 Maven 创建 war 包后，也可以正常部署到独立的 Tomcat 服务器中。</li>
</ol>

<essay>
看吧，你需要做一些基础的东西，才能在此基础上理方便地处理事物。
</essay>

<p>
对 SpringBoot 有所了解的童鞋可能知道，SpringBoot 也支持在 <code>main()</code> 方法中一行代码直接启动 Tomcat，并且还能方便地更换成 Jetty 等其他服务器，它的启动方式和我们介绍的是基本一样的。
</p>

<essay>
幸运地是，许多繁琐的事情都已经有了比较成熟的解决方式，但是为什么采取这些方式，以及它们的优缺点还是需要了然于胸的。
</essay>
</div>
</div>

<div id="outline-container-org4f2e6b6" class="outline-2">
<h2 id="org4f2e6b6">Servlet 是什么</h2>
<div class="outline-text-2" id="text-org4f2e6b6">
<p>
好的，下面我们就来具体认识一下 Servlet 是什么。
</p>

<img
src="/images/java/java-33.jpg"
width="200"
height=""
style="float: left;margin-right: 10px;"
title=""
/>

<p>
Servlet 是 Server Applet 的简称，译为“服务器端小程序”。它是 Java 的一套技术标准，规定了如何使用 Java 来开发动态网站。换句话说，Java 可以用来开发网站后台，但是要提前定义好一套规范，并编写基础类库，这就是 Servlet 所做的事情。
</p>

<p>
Java Servlet 可以使用所有的 Java API ，Java 能做的事情，Servlet 都能做。
</p>

<p>
#+BEGIN<sub>QUOTE</sub>
Servlet 只是古老的 CGI 技术的替代品，然而直接使用 Servlet 开发还是很麻烦，所以 Java 后来又对 Servlet 进行了升级，推出了 JSP 技术。本质上，JSP 只是对 Servlet 加了一层壳，JSP 经过编译后还是 Servlet 。
#+END<sub>QUOTE</sub>。
</p>

<essay>
程序嘛，最终都是要变为二进制的 0 和 1 ，所以，一切不过都是抽象，一层一层的抽象罢了。
</essay>

<p>
Servlet 是 Java Servlet 的简称，是使用 Java 语言编写的运行在服务器端的程序，具有独立平台和协议的特性，主要功能在于交互式地浏览和生成数据，生成动态 Web 内容。
</p>

<p>
<b>通常来说，Servlet 是指所有实现了 Servlet 接口的类。</b>
</p>

<ul class="org-ul">
<li>Servlet 主要用于处理客户端传来的 HTTP 请求，并返回一个响应，它能够处理的请求有 <code>doGet()</code> 和 <code>doPost()</code> 等；</li>
<li>Servlet 由 Servlet 容器提供，所谓 Servlet 容器就是指提供了 Servlet 功能的服务器（如 Tomcat）；</li>
<li>Servlet 容器会将 Servlet 动态加载到服务器上，然后通过 HTTP 请求和 HTTP 响应与客户端进行交互。</li>
</ul>

<p>
Servlet 应用程序的体系结构如下：
</p>

<img
src="/images/java/java-34.gif"
width=""
height=""
style=""
title=""
/>

<p>
如上图中，Servlet 的请求首先会被 HTTP 服务器（如 Apache、Nginx）接收，HTTP 服务器只负责静态 HTML 页面的解析，而 Servlet 的请求会转交给 Servlet 容器，Servlet 容器会根据 <code>web.xml</code> 文件中的映射关系，调用相应的 Servlet ，Servlet 再将处理的结果返回给 Servlet 容器，并通过 HTTP 服务器将响应传输给客户端。
</p>
</div>
</div>

<div id="outline-container-org8caff6a" class="outline-2">
<h2 id="org8caff6a">Servlet 相关的接口和类</h2>
<div class="outline-text-2" id="text-org8caff6a">
<p>
SUN 公司提供了一系列的接口和类用于 Servlet 技术的开发（缅怀一下 SUN 公司吧），其中最重要的接口是 <code>javax.servlet.Servlet</code> 。在 Servlet 接口中定义了 5 个抽象方法，如下表：
</p>
<table>
<caption class="t-above"><span class="table-number">Table 1:</span> Servlet 接口的抽象方法</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">方法声明</th>
<th scope="col" class="org-left">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>void init(ServletConfig config)</code></td>
<td class="org-left">容器在创建好 Servlet 对象后，就会调用此方法。该方法接收一个 ServletConfig 类型的参数，Servlet 容器通过该参数向 Servlet 传递初始化配置信息</td>
</tr>

<tr>
<td class="org-left"><code>ServletConfig getServletConfig()</code></td>
<td class="org-left">用于获取 Servlet 对象的配置信息，返回 Servlet 的 <code>ServletConfig</code> 对象</td>
</tr>

<tr>
<td class="org-left"><code>String getServletInfo()</code></td>
<td class="org-left">返回一个字符串，其中包含关于 Servlet 的信息，如作者、版本和版权等信息</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>void service(ServletRequest request, ServletResponse response)</code></td>
<td class="org-left">负责响应用户的请求，当容器接收到客户端访问 Servlet 对象的请求时，就会调用此方法。</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">容器会构造一个表示客户端请求信息的 <code>ServletRequest</code> 对象和一个用于响应客户端的 <code>ServletResponse</code> 对象作为参数传递给 <code>service()</code> 方法。</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">在 <code>service()</code> 方法中，可以通过 <code>ServletRequest</code> 对象得到客户端的相关信息和请求信息，在对请求进行处理后，调用 <code>ServletResponse</code> 对象的方法设置响应信息</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><code>void destroy()</code></td>
<td class="org-left">负责释放 Servlet 对象占用的资源，当服务器关闭或者 Servlet 对象被移除时，Servlet 对象会被销毁，容器会调用此方法</td>
</tr>
</tbody>
</table>

<p>
在表中，列举了 Servlet 接口中的五个方法，其中 <code>init()、service()</code> 和 <code>destroy()</code> 方法可以表现 Servlet 的生命周期，它们会在某个特定的时刻被调用。
</p>

<p>
<b>针对 Servlet 的接口，SUN 公司提供了现个默认的接口实现类： <code>GenericServlet</code> 和 <code>HttpServlet</code> 。</b> 其中：
</p>
<ul class="org-ul">
<li><code>GenericServlet</code> 是一个抽象类，该类为 Servlet 接口提供了部分实现，它并没有实现 HTTP 请求处理；</li>
<li><code>HttpServlet</code> 是 <code>GenericServlet</code> 的子类，它继承了 <code>GenericServlet</code> 的所有方法，并且为 HTTP 请求中的 GET 和 POST 等类型提供了具体的操作方法。</li>
</ul>

<p>
*注：通常情况下，编写的 Servlet 类都继承自 <code>HttpServlet</code> ，在开发中使用的也是 <code>HttpServlet</code> 对象。
</p>

<table>
<caption class="t-above"><span class="table-number">Table 2:</span> HttpServlet 类的常用方法</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">方法声明</th>
<th scope="col" class="org-left">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>protected void doGet(HttpServletRequest req, HttpServletResponse resp)</code></td>
<td class="org-left">用于处理 GET 类型的 HTTP 请求的方法</td>
</tr>

<tr>
<td class="org-left"><code>protected void doPost(HttpServletRequest req, HttpServletResponse resp)</code></td>
<td class="org-left">用于处理 POST 类型的 HTTP 请求的方法</td>
</tr>
</tbody>
</table>

<p>
HttpServlet 主要有两大功能，具体如下：
</p>
<ul class="org-ul">
<li>根据用户请求方式的不同，定义相应的 <code>doXxx()</code> 方法处理用户请求，例如，与 GET 请求方式对应的 <code>doGet()</code> 方法，与 POST 方式对应的 <code>doPost()</code> 方法；</li>
<li>通过 <code>service()</code> 方法将 HTTP 请求和响应分别强转为 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 类型的对象。</li>
</ul>

<p>
*注：需要注意的是，由于 HttpServlet 类在重写的 <code>service()</code> 方法，为每一种 HTTP 请求方式都定义了对应的 <code>doXxx()</code> 方法，因此，当定义的类的继承 HttpServlet 后，只需要根据请求方式重写对应的 <code>doXxx()</code> 方法即可，而不需要重写 <code>service()</code> 方法。
</p>
</div>
</div>

<div id="outline-container-org863af58" class="outline-2">
<h2 id="org863af58">Servlet 生命周期</h2>
<div class="outline-text-2" id="text-org863af58">
<p>
在 Java 中，任何对象都有生命周期，Servlet 也不例外，其生命周期如下：
</p>

<img
src="/images/java/java-35.png"
width="510"
height=""
style=""
title=""
/>

<p>
按照功能的不同，大致可以将 Servlet 的生命周期分为三个阶段，分别是初始化阶段、运行阶段和销毁阶段。
</p>

<p>
<span class="underline">1. 初始化阶段</span>
</p>

<p>
当客户端向 Servlet 容器发出 HTTP 请求要求访问 Servlet 时，Servlet 容器首先会解析请求，检查内存中是否已经有了该 Servlet 对象，如果有，则直接使用该 Servlet 对象，如果没有，则创建 Servlet 实例对象，然后通过调用 <code>init()</code> 方法实现 Servlet 的初始化工作。
</p>

<p>
*注：在 Servlet 的整个生命周期内，它的 <code>init()</code> 方法只能被调用一次。
</p>

<p>
<span class="underline">2. 运行阶段</span>
</p>

<p>
这是 Servlet 生命周期中最重要的阶段，在这个阶段中，Servlet 容器会为这个请求创建代表 HTTP 请求的 <code>ServletRequest</code> 对象和代表 HTTP 响应的 <code>ServletResponse</code> 对象，然后将它们作为参数传递给 Servlet 的 <code>service()</code> 方法。
</p>

<p>
<code>service()</code> 方法从 <code>ServletRequest</code> 对象中获得请求信息并处理该请求，通过 <code>ServletResponse</code> 对象生成响应结果。
</p>

<p>
在 Servlet 的整个生命周期内，对于 Servlet 的每一次访问请求，Servlet 容器都会调用一次 Servlet 的 <code>service()</code> 方法，并且创建新的 <code>ServletRequest</code> 和 <code>ServletResponse</code> 对象。
</p>

<p>
*注：也就是说， <code>service()</code> 方法在 Servlet 的整个生命周期中会被调用多次。
</p>

<p>
<span class="underline">3. 销毁阶段</span>
</p>

<p>
当服务器关闭或 Web 应用被移除出容器时，Servlet 随着 Web 应用的关闭而销毁。在销毁 Servlet 之前，Servlet 容器会调用 Servlet 的 <code>destroy()</code> 方法，以便让 Servlet 对象释放它所占用的资源（Servlet 对象一旦创建就会驻留在内存中等待客户端的访问）。
</p>

<p>
*注：在 Servlet 的整个生命周期中， <code>destroy()</code> 方法也只能被调用一次。
</p>
</div>
</div>

<div id="outline-container-org1d7c57f" class="outline-2">
<h2 id="org1d7c57f">第一个 Servlet 程序</h2>
<div class="outline-text-2" id="text-org1d7c57f">
<p>
<span class="underline">1. 创建 Web 项目</span>
</p>

<p>
<span class="underline">2. 创建 Servlet 程序</span>
</p>

<p>
<span class="underline">3. 部署和访问 Servlet</span>
</p>

<essay>
Hmmm... 大致就是这么个过程，具体如何结合的，找个专题慢慢聊。
</essay>
</div>
</div>

<div id="outline-container-org4a30b02" class="outline-2">
<h2 id="org4a30b02">Servlet 虚拟路径映射的配置</h2>
<div class="outline-text-2" id="text-org4a30b02">
<p>
在 <code>web.xml</code> 文件中，一个 <code>&lt;servlet-mapping&gt;</code> 元素用于映射一个 Servlet 的对外访问路径，该路径也称为虚拟路径。
</p>

<div class="org-src-container">
<pre class="src src-xml"><span class="linenr">1: </span><span style="color: #75715E;">&lt;!-- </span><span style="color: #75715E;">web.xml </span><span style="color: #75715E;">--&gt;</span>
<span class="linenr">2: </span>...
<span class="linenr">3: </span>&lt;<span style="color: #A6E22E;">servlet-mapping</span>&gt;
<span class="linenr">4: </span>  &lt;<span style="color: #A6E22E;">servlet-name</span>&gt;TestServlet01&lt;/<span style="color: #A6E22E;">servlet-name</span>&gt;
<span class="linenr">5: </span>  &lt;<span style="color: #A6E22E;">url-pattern</span>&gt;/TestServlet01&lt;/<span style="color: #A6E22E;">url-pattern</span>&gt;
<span class="linenr">6: </span>&lt;/<span style="color: #A6E22E;">servlet-mapping</span>&gt;
<span class="linenr">7: </span>...
</pre>
</div>

<p>
如上，  <code>TestServlet01</code> 所映射的虚拟路径为 <code>/TestServlet01</code> 。
</p>

<p>
*注：创建好的 Servlet 只有映射成虚拟路径，客户端才能对其进行访问。
</p>

<blockquote>
<p>
在映射 Servlet 时，需要了解 Servlet 的多重映射、在映射路径中使用通配符、配置默认的 Servlet 等。
</p>
</blockquote>
</div>

<div id="outline-container-org9ff7fb0" class="outline-3">
<h3 id="org9ff7fb0">Servlet 的多重映射</h3>
<div class="outline-text-3" id="text-org9ff7fb0">
<p>
Servlet 的多重映射指同一个 Servlet 可以被映射成多条虚拟路径。也就是说，客户端可以通过多条路径实现对同一个 Servlet 的访问。
</p>

<p>
那么，如何 Servlet 多重映射的实现方式有哪些呢？两种。
</p>

<p>
<span class="underline">1. 配置多个 &lt;servlet-mapping&gt; 元素</span>
</p>

<div class="org-src-container">
<pre class="src src-xml"><span class="linenr"> 1: </span><span style="color: #75715E;">&lt;!-- </span><span style="color: #75715E;">web.xml </span><span style="color: #75715E;">--&gt;</span>
<span class="linenr"> 2: </span>...
<span class="linenr"> 3: </span>&lt;<span style="color: #A6E22E;">servlet-mapping</span>&gt;
<span class="linenr"> 4: </span>  &lt;<span style="color: #A6E22E;">servlet-name</span>&gt;TestServlet01&lt;/<span style="color: #A6E22E;">servlet-name</span>&gt;
<span class="linenr"> 5: </span>  &lt;<span style="color: #A6E22E;">url-pattern</span>&gt;/TestServlet01&lt;/<span style="color: #A6E22E;">url-pattern</span>&gt;
<span class="linenr"> 6: </span>&lt;/<span style="color: #A6E22E;">servlet-mapping</span>&gt;
<span class="linenr"> 7: </span>&lt;<span style="color: #A6E22E;">servlet-mapping</span>&gt;
<span class="linenr"> 8: </span>  &lt;<span style="color: #A6E22E;">servlet-name</span>&gt;TestServlet01&lt;/<span style="color: #A6E22E;">servlet-name</span>&gt;
<span class="linenr"> 9: </span>  &lt;<span style="color: #A6E22E;">url-pattern</span>&gt;/Test01&lt;/<span style="color: #A6E22E;">url-pattern</span>&gt;
<span class="linenr">10: </span>&lt;/<span style="color: #A6E22E;">servlet-mapping</span>&gt;
<span class="linenr">11: </span>...
</pre>
</div>

<p>
<span class="underline">2. 配置多个 &lt;url-pattern&gt; 子元素</span>
</p>

<div class="org-src-container">
<pre class="src src-xml"><span class="linenr">1: </span><span style="color: #75715E;">&lt;!-- </span><span style="color: #75715E;">web.xml </span><span style="color: #75715E;">--&gt;</span>
<span class="linenr">2: </span>...
<span class="linenr">3: </span>&lt;<span style="color: #A6E22E;">servlet-mapping</span>&gt;
<span class="linenr">4: </span>    <span style="color: #75715E;">&lt;!-- </span><span style="color: #75715E;">&#26144;&#23556;&#20026;TestServlet01&#21644;Test02 </span><span style="color: #75715E;">--&gt;</span>
<span class="linenr">5: </span>    &lt;<span style="color: #A6E22E;">servlet-name</span>&gt;TestServlet01&lt;/<span style="color: #A6E22E;">servlet-name</span>&gt;
<span class="linenr">6: </span>    &lt;<span style="color: #A6E22E;">url-pattern</span>&gt;/TestServlet01&lt;/<span style="color: #A6E22E;">url-pattern</span>&gt;
<span class="linenr">7: </span>    &lt;<span style="color: #A6E22E;">url-pattern</span>&gt;/Test02&lt;/<span style="color: #A6E22E;">url-pattern</span>&gt;
<span class="linenr">8: </span>&lt;/<span style="color: #A6E22E;">servlet-mapping</span>&gt;
<span class="linenr">9: </span>...
</pre>
</div>
</div>
</div>

<div id="outline-container-org6bcd272" class="outline-3">
<h3 id="org6bcd272">Servlet 映射路径中使用通配符</h3>
<div class="outline-text-3" id="text-org6bcd272">
<p>
在实际开发过程中，开发者有时会希望某个目录下的所有路径都可以访问同一个 Servlet ，这时，可以在 Servlet 映射的路径中使用通配符 <code>*</code> 。
</p>

<p>
通配符的格式有两种：
</p>
<ul class="org-ul">
<li>格式为 <code>*.扩展名</code> ，例如 <code>*.do</code> 匹配以 <code>.do</code> 结尾的所有 URL 地址；</li>
<li>格式为 <code>/*</code> ，例如 <code>/abc/*</code> 匹配以 <code>/abc</code> 开始的所有 URL 地址。</li>
</ul>

<p>
但是，这两种通配符的格式 <b>不能混合使用</b> ，例如， <code>/abc/*.do</code> 是不合法的映射路径。
</p>

<p>
当客户端访问一个 Servlet 时，如果请求的 URL 地址能够匹配多条虚拟路径，那么 Tomcat 将采取最具体匹配原则查找与请求 URL <b>最接近的</b> 虚拟映射路径。
</p>
</div>
</div>

<div id="outline-container-orgfa95d30" class="outline-3">
<h3 id="orgfa95d30">默认 Servlet</h3>
<div class="outline-text-3" id="text-orgfa95d30">
<p>
如果某个 Servlet 的映射路径仅仅是一个正斜线（ <code>/</code> ），那么这个 Servlet 就是当前 Web 应用的默认 Servlet。Servlet 服务器在接收到访问请求时，如果在 <code>web.xml</code> 文件中找不到匹配的 <code>&lt;servlet-mapping&gt;</code> 元素的 URL ，则会将访问请求交给默认 Servlet 处理。
</p>
</div>
</div>
</div>

<div id="outline-container-orgf0264fb" class="outline-2">
<h2 id="orgf0264fb">ServletConfig 和 ServletContext 接口</h2>
<div class="outline-text-2" id="text-orgf0264fb">
</div>
<div id="outline-container-orgf36789b" class="outline-3">
<h3 id="orgf36789b">ServletConfig 接口</h3>
<div class="outline-text-3" id="text-orgf36789b">
<p>
在运行 Servlet 程序时，可能需要一些辅助信息，例如，文件使用的编码、使用 Servlet 程序的共享信息等，这些信息可以在 web.xml 文件中使用一个或多个 <code>&lt;init-param&gt;</code> 元素进行配置。
</p>

<p>
当 Tomcat 初始化一个 Servlet 时，会将该 Servlet 的配置信息封装到 <code>ServletConfig</code> 对象中，此时可以通过调用 <code>init(ServletConfig config)</code> 方法将 <code>ServletConfig</code> 对象传递给 Servlet 。
</p>

<table>
<caption class="t-above"><span class="table-number">Table 3:</span> ServletConfig 接口的常用方法</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">方法说明</th>
<th scope="col" class="org-left">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>String getInitParameter(String name)</code></td>
<td class="org-left">根据初始化参数名返回对应的初始化参数值</td>
</tr>

<tr>
<td class="org-left"><code>Enumeration getInitParameterNames()</code></td>
<td class="org-left">返回一个 <code>Enumeration</code> 对象，其中包含了所有的初始化参数名</td>
</tr>

<tr>
<td class="org-left"><code>ServletContext getServletContext()</code></td>
<td class="org-left">返回一个代表当前 Web 应用的 <code>ServletContext</code> 对象</td>
</tr>

<tr>
<td class="org-left"><code>String getServletName()</code></td>
<td class="org-left">返回 Servlet 的名字，即 <code>web.xml</code> 中 <code>&lt;servlet-name&gt;</code> 元素的值</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org4b38eb9" class="outline-3">
<h3 id="org4b38eb9">ServletContext 接口</h3>
<div class="outline-text-3" id="text-org4b38eb9">
<p>
当 Tomcat 启动时，Tomcat 会为每个 Web 应用创建一个唯一的 <code>ServletContext</code> 对象代表当前的 Web 应用，该对象封装了当前 Web 应用的所有信息。可以利用该对象获取 Web 应用程序的初始化信息、读取资源文件等。
</p>

<p>
<span class="underline">1. 获取 Web 应用程序的初始化参数</span>
</p>

<p>
在 web.xml 文件中，不仅可以配置 Servlet 的映射信息，还可以配置整个 Web 应用的初始化信息。
</p>

<p>
Web 应用初始化参数的配置方式具体如下：
</p>

<div class="org-src-container">
<pre class="src src-xml"><span class="linenr"> 1: </span><span style="color: #75715E;">&lt;!-- </span><span style="color: #75715E;">web.xml </span><span style="color: #75715E;">--&gt;</span>
<span class="linenr"> 2: </span>...
<span class="linenr"> 3: </span>&lt;<span style="color: #A6E22E;">context-param</span>&gt;
<span class="linenr"> 4: </span>    &lt;<span style="color: #A6E22E;">param-name</span>&gt;XXX&lt;/<span style="color: #A6E22E;">param-name</span>&gt;
<span class="linenr"> 5: </span>    &lt;<span style="color: #A6E22E;">param-value</span>&gt;xxx&lt;/<span style="color: #A6E22E;">param-value</span>&gt;
<span class="linenr"> 6: </span>&lt;/<span style="color: #A6E22E;">context-param</span>&gt;
<span class="linenr"> 7: </span>&lt;<span style="color: #A6E22E;">context-param</span>&gt;
<span class="linenr"> 8: </span>    &lt;<span style="color: #A6E22E;">param-name</span>&gt;AAA&lt;/<span style="color: #A6E22E;">param-name</span>&gt;
<span class="linenr"> 9: </span>    &lt;<span style="color: #A6E22E;">param-value</span>&gt;aaa&lt;/<span style="color: #A6E22E;">param-value</span>&gt;
<span class="linenr">10: </span>&lt;/<span style="color: #A6E22E;">context-param</span>&gt;
<span class="linenr">11: </span>...
</pre>
</div>

<p>
在上面的示例中， <code>&lt;context-param&gt;</code> 元素位于根元素 <code>&lt;web-app&gt;</code> 中，它的子元素 <code>&lt;param-name&gt;</code> 和 <code>&lt;param-value&gt;</code> 分别用于指定参数的名字和参数值。
</p>

<p>
要想获取这些参数名和参数值的信息，可以使用 <code>ServletContext</code> 接口中定义的 <code>getInitParameterNames()</code> 和 <code>getInitParameter(String name)</code> 方法分别获取。
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #F92672;">public</span> <span style="color: #F92672;">class</span> <span style="color: #66D9EF;">TestServlet</span> <span style="color: #F92672;">extends</span> <span style="color: #66D9EF;">HttpServlet</span> <span style="color: #AE81FF;">{</span>
<span class="linenr"> 2: </span>    <span style="color: #F92672;">public</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">doGet</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">HttpServletRequest</span> <span style="color: #FD971F;">req</span>, <span style="color: #66D9EF;">HttpServletResponse</span> <span style="color: #FD971F;">resp</span><span style="color: #66D9EF;">)</span> <span style="color: #F92672;">throws</span> <span style="color: #66D9EF;">ServletException</span>, <span style="color: #66D9EF;">IOException</span> <span style="color: #66D9EF;">{</span>
<span class="linenr"> 3: </span>        res.setContentType<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"text/html;charset=utf-8"</span><span style="color: #A6E22E;">)</span>;
<span class="linenr"> 4: </span>        <span style="color: #66D9EF;">PrintWriter</span> <span style="color: #FD971F;">out</span> = resp.getWriter<span style="color: #A6E22E;">()</span>;
<span class="linenr"> 5: </span>        <span style="color: #75715E;">// </span><span style="color: #75715E;">&#24471;&#21040; ServletContext &#23545;&#35937;</span>
<span class="linenr"> 6: </span>        <span style="color: #66D9EF;">ServletContext</span> <span style="color: #FD971F;">context</span> = <span style="color: #F92672;">this</span>.getServletContext<span style="color: #A6E22E;">()</span>;
<span class="linenr"> 7: </span>        <span style="color: #75715E;">// </span><span style="color: #75715E;">&#24471;&#21040;&#21253;&#21547;&#25152;&#26377;&#21021;&#22987;&#21270;&#21442;&#25968;&#21517;&#30340; Enumeration &#23545;&#35937;</span>
<span class="linenr"> 8: </span>        <span style="color: #66D9EF;">Enumeration</span><span style="color: #A6E22E;">&lt;</span><span style="color: #66D9EF;">String</span><span style="color: #A6E22E;">&gt;</span> <span style="color: #FD971F;">paramNames</span> = context.getInitParameterNames<span style="color: #A6E22E;">()</span>;
<span class="linenr"> 9: </span>        <span style="color: #75715E;">// </span><span style="color: #75715E;">&#36941;&#21382;&#25152;&#26377;&#30340;&#21021;&#22987;&#21270;&#21442;&#25968;&#21517;&#65292;&#24471;&#21040;&#30456;&#24212;&#30340;&#21442;&#25968;&#20540;&#24182;&#25171;&#21360;</span>
<span class="linenr">10: </span>        <span style="color: #F92672;">while</span> <span style="color: #A6E22E;">(</span>paramNames.hasMoreElements<span style="color: #E6DB74;">()</span><span style="color: #A6E22E;">)</span> <span style="color: #A6E22E;">{</span>
<span class="linenr">11: </span>            <span style="color: #66D9EF;">String</span> <span style="color: #FD971F;">name</span> = paramNames.nextElement<span style="color: #E6DB74;">()</span>;
<span class="linenr">12: </span>            <span style="color: #66D9EF;">String</span> <span style="color: #FD971F;">value</span> = context.getInitparameter<span style="color: #E6DB74;">(</span>name<span style="color: #E6DB74;">)</span>;
<span class="linenr">13: </span>            out.println<span style="color: #E6DB74;">(</span>name + <span style="color: #E6DB74;">":"</span> + value<span style="color: #E6DB74;">)</span>;
<span class="linenr">14: </span>            out.println<span style="color: #E6DB74;">(</span><span style="color: #E6DB74;">"&lt;br/&gt;"</span><span style="color: #E6DB74;">)</span>;
<span class="linenr">15: </span>        <span style="color: #A6E22E;">}</span>
<span class="linenr">16: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">17: </span>    ...
<span class="linenr">18: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
<span class="underline">2.TODO 读取 Web 应用下的资源文件</span>
</p>

<p>
在实际开发中，有时会需要读取 Web 应用中的一些资源文件，如配置文件和日志文件等。为此，在 <code>ServletContext</code> 接口中定义了一些读取 Web 资源的方法，这些方法是依靠 Servlet 容器实现的。
</p>

<p>
Servlet 容器根据资源文件相对于 Web 应用的路径，返回关联资源文件的 I/O 流或资源文件在系统的绝对路径等。
</p>
</div>
</div>
</div>

<div id="outline-container-org5573327" class="outline-2">
<h2 id="org5573327">Servlet 处理用户请求的完整流程</h2>
<div class="outline-text-2" id="text-org5573327">
<p>
针对 Servlet 的每次请求，Web 服务器在调用 <code>service()</code> 方法之前，都会创建 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 对象。其中， <code>HttpServletRequest</code> 对象用于封装 HTTP 请求消息，简称 <code>request</code> 对象。 <code>HttpServletResponse</code> 对象用于封装 HTTP 响应信息，简称 <code>response</code> 对象。
</p>

<img
src="/images/java/java-36.png"
width="600"
height=""
style=""
title=""
/>
<p>
<code>Figure: 浏览器访问 Servlet 过程</code>
</p>

<p>
如图，首先浏览器向 Web 服务器发送了一个 HTTP 请求，Web 服务器根据收到的请求，会先创建一个 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 对象，然后再调用相应的 Servlet 程序。
</p>

<p>
在 Servlet 程序运行时，它首先会从 <code>HttpServletRequest</code> 对象中读取数据信息，然后通过 <code>service()</code> 方法处理请求消息，并将处理后的响应数据写入到 <code>HttpServletResponse</code> 对象中。最后，Web 服务器会从 <code>HttpServletResponse</code> 对象中读取到响应数据，并发送给浏览器。
</p>

<p>
需要注意的是，在 Web 服务器运行阶段，每个 Servlet 都只会创建一个实例对象，针对每次 HTTP 请求，Web 服务器都会调用所请求 Servlet 实例的 <code>service(HttpServletRequest request, HttpServletResponse response)</code> 方法，并重新创建一个 <code>request</code> 对象和一个 <code>response</code> 对象。
</p>
</div>
</div>

<div id="outline-container-org6fa569b" class="outline-2">
<h2 id="org6fa569b">HttpServletRequest</h2>
<div class="outline-text-2" id="text-org6fa569b">
<p>
<code>HttpServletRequest</code> 接口继承处 <code>ServletRequest</code> 接口，其主要使用是封装 HTTP 请求信息。
</p>

<p>
由于 HTTP 请求消息分为请求行、请求消息头和请求消息体三部分。因此，在 <code>HttpServletRequest</code> 接口中定义了获取请求行、请求头和请求消息体的相关方法。
</p>
</div>

<div id="outline-container-org2e6eb50" class="outline-3">
<h3 id="org2e6eb50">获取请求行信息的相关方法<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup></h3>
<div class="outline-text-3" id="text-org2e6eb50">
<p>
当访问 Servlet 时，所有请求消息将被封装到 <code>HttpServletRequest</code> 对象中，请求消息的请求行中包含请求方法、请求资源名、请求路径等信息，为了获取这些信息， <code>HttpServletRequest</code> 接口定义了一系列方法。
</p>

<essay>
具体的属性表格，用的时候再查就好了。
</essay>
</div>
</div>

<div id="outline-container-org6b85d99" class="outline-3">
<h3 id="org6b85d99">获取请求消息头的相关方法</h3>
<div class="outline-text-3" id="text-org6b85d99">
<p>
当浏览器发送 Servlet 请求时，需要通过请求消息头向服务器传递附加信息，例如，客户端可以接收的数据类型、压缩方式、语言等。为此，在 <code>HttpServletRequest</code> 接口中定义了一系列获取 HTTP 请求字段的方法。
</p>
</div>
</div>

<div id="outline-container-org9212f46" class="outline-3">
<h3 id="org9212f46"><span class="todo TODO">TODO</span> Servlet 获取 form 表单数据</h3>
<div class="outline-text-3" id="text-org9212f46">
<p>
Request 对象不仅可以获取一系列数据，还可以通过属性传递数据。
</p>
</div>
</div>

<div id="outline-container-org430f353" class="outline-3">
<h3 id="org430f353">RequestDispatcher 实现请求转发<sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup></h3>
<div class="outline-text-3" id="text-org430f353">
<p>
当一个 Web 资源收到客户端的请求后，如果希望服务器通知另外一个资源处理请求，可以通过 <code>RequestDispatcher</code> 接口的实例对象实现。
</p>

<essay>
老规矩喽，相关具体的属性列表有些了解就好，用的时候再查就行了，不经过反复的实践，你也记不住。
</essay>

<img
src="/images/java/java-37.png"
width="420"
height=""
style=""
title=""
/>
<p>
<code>Figure：forward() 方法的工作原理</code>
</p>

<p>
在 <code>RequestDispatcher</code> 接口中， <code>forward()</code> 方法可以实现请求转发， <code>include()</code> 方法可以实现请求包含。
</p>

<p>
如图：当客户端访问 Servlet1 时，可以通过 <code>forward()</code> 方法将请求转发给其他 Web 资源，其他 Web 资源处理完请求后，直接将响应结果返回到客户端。
</p>
</div>
</div>
</div>

<div id="outline-container-orge72f188" class="outline-2">
<h2 id="orge72f188">HttpServletResponse</h2>
<div class="outline-text-2" id="text-orge72f188">
<p>
<code>HttpServletResponse</code> 接口继承自 <code>ServletResponse</code> 接口，主要用于封装 HTTP 响应消息。
</p>

<p>
由于 HTTP 响应消息分为状态行、响应消息头、消息体三部分。因此，在 <code>HttpServletResponse</code> 接口中定义了向客户端发送响应状态码、响应消息头、响应消息体的方法。
</p>
</div>

<div id="outline-container-org2312f82" class="outline-3">
<h3 id="org2312f82">发送状态码相关的方法</h3>
<div class="outline-text-3" id="text-org2312f82">
<p>
当 Servlet 向客户端回送响应消息时，需要在响应消息中设置状态码。因此， <code>HttpServletResponse</code> 接口定义了两个发送状态码的方法。
</p>

<p>
<span class="underline">1. setStatus(int status) 方法</span>
</p>

<p>
该方法用于设置 HTTP 响应消息的状态码，并生成响应状态行。
</p>

<p>
由于响应状态行中的状态描述信息直接与状态码相关，而 HTTP 版本由服务器确定，因此，只要通过 <code>setStatus(ini status)</code> 方法设置了状态码，即可实现状态行的发送。
</p>

<p>
*注：在正常情况下，Web 服务器会默认产生一个状态码为 <code>200</code> 的状态行。
</p>

<p>
<span class="underline">2. sendError(int sc) 方法</span>
</p>

<p>
该方法用于发送表示错误信息的状态码。例如， <code>404</code> 状态码表示找不到客户端请求的资源。
</p>

<p>
<code>response</code> 对象提供了现个重载的 <code>sendError(int sc)</code> 方法，具体如下：
</p>

<pre class="example">
public void sendError(int code) throws java.io.IOException
public void sendError(int code, String message) throws java.io.IOException
</pre>

<p>
在上面重载的两个方法中，第一个方法只发送错误信息的状态码，而第二个方法除了发送状态以外，还可以增加一条用于提示说明的文本信息，该文本信息将出现在发送给客户端的正文内容中。
</p>
</div>
</div>

<div id="outline-container-orgdb6e6ac" class="outline-3">
<h3 id="orgdb6e6ac">发送响应消息头相关的方法</h3>
<div class="outline-text-3" id="text-orgdb6e6ac">
<p>
Servlet 向客户端发送的响应消息中包含响应头字段，由于 HTTP 协议的响应头字段有很多种，因此， <code>HttpServletResponse</code> 接口定义了一系列设置 HTTP 响应头字段的方法。
</p>
</div>
</div>

<div id="outline-container-orgad43dd1" class="outline-3">
<h3 id="orgad43dd1">发送响应消息体相关的方法</h3>
<div class="outline-text-3" id="text-orgad43dd1">
<p>
由于在 HTTP 响应消息中，大量的数据都是通过响应消息体传递的，因此， <code>ServletResponse</code> 遵循以 I/O 流传递大量数据的设计理念。在发送响应消息体时，定义了两个与输出流相关的方法。
</p>

<p>
<span class="underline">1. getOutputStream() 方法</span>
</p>

<p>
该方法所获取的字节输出流对象为 <code>ServletOutputStream</code> 类型。
</p>

<p>
由于 <code>ServletOutputStream</code> 是 <code>OutputStream</code> 的子类，它可以直接输出字节数组中的二进制数据。因此，要想输出二进制格式的响应正文，就需要使用 <code>getOutputStream()</code> 方法。
</p>

<p>
<span class="underline">2. getWriter() 方法</span>
</p>

<p>
该方法所获取的字符输出流对象为 <code>PrintWriter</code> 类型。
</p>

<p>
由于 PrintWriter 类型的对象可以直接输出字符文本内容，因此，要想输出内容全部为字符文本的网页文档，则需要使用 <code>getWriter()</code> 方法。
</p>

<p>
*注：虽然 <code>response</code> 对象的 <code>getOutputStream()</code> 和 <code>getWriter()</code> 方法都可以发送响应消息体，但是，它们之间互相排斥，不可同时使用，否则会发生 <code>IllegalStateException</code> 异常。
</p>
</div>
</div>

<div id="outline-container-orga6b9181" class="outline-3">
<h3 id="orga6b9181">sendRedirect() 实现重写向</h3>
<div class="outline-text-3" id="text-orga6b9181">
<p>
在某些情况下，针对客户端的请求，一个 Servlet 类可能无法完成全部工作，这时，可以使用请求重定向完成这一工作。
</p>

<p>
<span class="underline">请求重定向</span> 指 Web 服务器接收到客户端的请求后，可能由于某些条件的限制，不能访问当前请求 URL 所指向的 Web 资源，而是指定了一个新的资源路径，让客户端重新发送请求。
</p>

<p>
为了实现请求重定向， <code>HttpServletResponse</code> 接口定义了一个 <code>sendRedirect()</code> 方法，该方法用于生成 <code>302</code> 响应码和 <code>Location</code> 响应头，从而通知客户端重新访问 <code>Location</code> 响应中指定的 URL ， <code>sendRedirect()</code> 方法的完整语法如下所示：
</p>

<pre class="example">
public void sendRedirect(java.lang.String.location) throws java.io.IOException
</pre>

<p>
在上述方法代码中，参数 <code>location</code> 可以使用相对  URL ，Web 服务器会自动将相对 URL 翻译成绝对 URL，再生成 <code>Location</code> 头字段。
</p>

<img
src="/images/java/java-38.png"
width="550"
height=""
style=""
title=""
/>
<p>
<code>Figure：sendRedirect() 方法的工作原理</code>
</p>

<p>
如图：当客户端访问 <code>Servlet1</code> 时，由于在 <code>Servlet1</code> 中调用了 <code>sendRedirect()</code> 方法将请求重定向到 <code>Servlet2</code> ，因此，浏览器收到 <code>Servlet1</code> 的响应消息后，立刻向 <code>Servlet2</code> 发送请求， <code>Servlet2</code> 对请求处理完毕后，再将响应消息回送给客户端浏览器并显示。
</p>

<p>
下面通过一个用户登录的案例分步骤讲解 sendRedirect() 方法的使用。
</p>

<p>
<span class="underline">1. 创建页面文件</span>
</p>

<p>
在servletDemo 项目的 WebContent 目录下创建一个用户登录的页面 <code>login.html</code> 和登录成功的页面 <code>welcome.html</code> ，如下：
</p>

<div class="org-src-container">
<pre class="src src-html"><span class="linenr"> 1: </span><span style="color: #75715E;">&lt;!-- </span><span style="color: #75715E;">login.html </span><span style="color: #75715E;">--&gt;</span>
<span class="linenr"> 2: </span><span style="color: #E6DB74;">&lt;!doctype html&gt;</span>
<span class="linenr"> 3: </span>&lt;<span style="color: #A6E22E;">html</span>&gt;
<span class="linenr"> 4: </span>  &lt;<span style="color: #A6E22E;">head</span>&gt;
<span class="linenr"> 5: </span>    &lt;<span style="color: #A6E22E;">meta</span> <span style="color: #FD971F;">charset</span>=<span style="color: #E6DB74;">"UTF-8"</span>/&gt;
<span class="linenr"> 6: </span>    &lt;<span style="color: #A6E22E;">title</span>&gt;<span style="font-weight: bold; text-decoration: underline;">&#29992;&#25143;&#30331;&#24405;</span>&lt;/<span style="color: #A6E22E;">title</span>&gt;
<span class="linenr"> 7: </span>  &lt;/<span style="color: #A6E22E;">head</span>&gt;
<span class="linenr"> 8: </span>  &lt;<span style="color: #A6E22E;">body</span>&gt;
<span class="linenr"> 9: </span>    <span style="color: #75715E;">&lt;!-- </span><span style="color: #75715E;">&#25226;&#34920;&#21333;&#20869;&#23481;&#25552;&#20132;&#21040; servletDemo &#24037;&#31243;&#19979;&#30340; LoginServlet </span><span style="color: #75715E;">--&gt;</span>
<span class="linenr">10: </span>    &lt;<span style="color: #A6E22E;">form</span> <span style="color: #FD971F;">action</span>=<span style="color: #E6DB74;">"/servletDemo/LoginServlet"</span> <span style="color: #FD971F;">method</span>=<span style="color: #E6DB74;">"POST"</span>&gt;
<span class="linenr">11: </span>      &#36134;&#21495;: &lt;<span style="color: #A6E22E;">input</span> <span style="color: #FD971F;">name</span>=<span style="color: #E6DB74;">"username"</span> <span style="color: #FD971F;">type</span>=<span style="color: #E6DB74;">"text"</span>  /&gt;&lt;<span style="color: #A6E22E;">br</span>/&gt;
<span class="linenr">12: </span>      &#23494;&#30721;: &lt;<span style="color: #A6E22E;">input</span> <span style="color: #FD971F;">name</span>=<span style="color: #E6DB74;">"password"</span> <span style="color: #FD971F;">type</span>=<span style="color: #E6DB74;">"password"</span> /&gt;&lt;<span style="color: #A6E22E;">br</span>/&gt;
<span class="linenr">13: </span>      &lt;<span style="color: #A6E22E;">br</span>/&gt;
<span class="linenr">14: </span>      &lt;<span style="color: #A6E22E;">input</span> <span style="color: #FD971F;">type</span>=<span style="color: #E6DB74;">"submit"</span> <span style="color: #FD971F;">value</span>=<span style="color: #E6DB74;">"&#30331;&#24405;"</span> /&gt;
<span class="linenr">15: </span>    &lt;/<span style="color: #A6E22E;">form</span>&gt;
<span class="linenr">16: </span>  &lt;/<span style="color: #A6E22E;">body</span>&gt;
<span class="linenr">17: </span>&lt;/<span style="color: #A6E22E;">html</span>&gt;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-html"><span class="linenr"> 1: </span><span style="color: #E6DB74;">&lt;!doctype html&gt;</span>
<span class="linenr"> 2: </span>&lt;<span style="color: #A6E22E;">html</span>&gt;
<span class="linenr"> 3: </span>  &lt;<span style="color: #A6E22E;">head</span>&gt;
<span class="linenr"> 4: </span>    &lt;<span style="color: #A6E22E;">meta</span> <span style="color: #FD971F;">charset</span>=<span style="color: #E6DB74;">"UTF-8"</span>/&gt;
<span class="linenr"> 5: </span>    &lt;<span style="color: #A6E22E;">title</span>&gt;<span style="font-weight: bold; text-decoration: underline;">&#27426;&#36814;&#39029;&#38754;</span>&lt;/<span style="color: #A6E22E;">title</span>&gt;
<span class="linenr"> 6: </span>  &lt;/<span style="color: #A6E22E;">head</span>&gt;
<span class="linenr"> 7: </span>  &lt;<span style="color: #A6E22E;">body</span>&gt;
<span class="linenr"> 8: </span>    &#27426;&#36814;&#20320;&#65292;&#30331;&#38470;&#25104;&#21151;&#65281;
<span class="linenr"> 9: </span>  &lt;/<span style="color: #A6E22E;">body</span>&gt;
<span class="linenr">10: </span>&lt;/<span style="color: #A6E22E;">html</span>&gt;
</pre>
</div>

<p>
<span class="underline">2. 创建 Servlet</span>
</p>

<p>
在 servletDemo 项目的 <code>com.mengma.response</code> 包中创建一个名为 <code>LoginServlet</code> 的 <code>Servlet</code> 类，用于处理用户登录请求，如下：
</p>

<div class="org-src-container">
<pre class="src src-java"><span class="linenr"> 1: </span><span style="color: #F92672;">package</span> com.mengma.<span style="color: #AE81FF;">servlet</span>;
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span><span style="color: #F92672;">import</span> <span style="color: #AE81FF;">java</span>.<span style="color: #AE81FF;">io</span>.<span style="color: #66D9EF;">IOException</span>;
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span><span style="color: #F92672;">import</span> <span style="color: #AE81FF;">javax</span>.<span style="color: #AE81FF;">servlet</span>.<span style="color: #66D9EF;">ServletException</span>;
<span class="linenr"> 6: </span><span style="color: #F92672;">import</span> <span style="color: #AE81FF;">javax</span>.<span style="color: #AE81FF;">servlet</span>.<span style="color: #AE81FF;">http</span>.<span style="color: #66D9EF;">HttpServlet</span>;
<span class="linenr"> 7: </span><span style="color: #F92672;">import</span> <span style="color: #AE81FF;">javax</span>.<span style="color: #AE81FF;">servlet</span>.<span style="color: #AE81FF;">http</span>.<span style="color: #66D9EF;">HttpServletRequest</span>;
<span class="linenr"> 8: </span><span style="color: #F92672;">import</span> <span style="color: #AE81FF;">javax</span>.<span style="color: #AE81FF;">servlet</span>.<span style="color: #AE81FF;">http</span>.<span style="color: #66D9EF;">HttpServletResponse</span>;
<span class="linenr"> 9: </span>
<span class="linenr">10: </span><span style="color: #F92672;">public</span> <span style="color: #F92672;">class</span> <span style="color: #66D9EF;">LoginServlet</span> <span style="color: #F92672;">extends</span> <span style="color: #66D9EF;">HttpServlet</span> <span style="color: #AE81FF;">{</span>
<span class="linenr">11: </span>    <span style="color: #F92672;">public</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">doGet</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">HttpServletRequest</span> <span style="color: #FD971F;">request</span>, <span style="color: #66D9EF;">HttpServletResponse</span> <span style="color: #FD971F;">response</span><span style="color: #66D9EF;">)</span>
<span class="linenr">12: </span>        <span style="color: #F92672;">throws</span> <span style="color: #66D9EF;">ServletException</span>, <span style="color: #66D9EF;">IOException</span> <span style="color: #66D9EF;">{</span>
<span class="linenr">13: </span>        response.setContentType<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"text/html;charset=utf-8"</span><span style="color: #A6E22E;">)</span>;
<span class="linenr">14: </span>        <span style="color: #75715E;">// </span><span style="color: #75715E;">&#29992; HttpServletRequest &#23545;&#35937;&#30340; getParameter() &#26041;&#27861;&#33719;&#21462;&#29992;&#25143;&#21517;&#21644;&#23494;&#30721;</span>
<span class="linenr">15: </span>        <span style="color: #66D9EF;">String</span> <span style="color: #FD971F;">username</span> = request.getParameter<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"username"</span><span style="color: #A6E22E;">)</span>;
<span class="linenr">16: </span>        <span style="color: #66D9EF;">String</span> <span style="color: #FD971F;">password</span> = request.getParameter<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"password"</span><span style="color: #A6E22E;">)</span>;
<span class="linenr">17: </span>        <span style="color: #75715E;">// </span><span style="color: #75715E;">&#20551;&#35774;&#29992;&#25143;&#21517;&#21644;&#23494;&#30721;&#20998;&#21035;&#20026; admin &#21644; 123456</span>
<span class="linenr">18: </span>        <span style="color: #F92672;">if</span> <span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">"admin"</span>.equals<span style="color: #E6DB74;">(</span>username<span style="color: #E6DB74;">)</span> &amp;&amp; <span style="color: #E6DB74;">(</span><span style="color: #E6DB74;">"123456"</span><span style="color: #E6DB74;">)</span>.equals<span style="color: #E6DB74;">(</span>password<span style="color: #E6DB74;">)</span><span style="color: #A6E22E;">)</span> <span style="color: #A6E22E;">{</span>
<span class="linenr">19: </span>            <span style="color: #75715E;">// </span><span style="color: #75715E;">&#22914;&#26524;&#29992;&#25143;&#21517;&#21644;&#23494;&#30721;&#27491;&#30830;&#65292;&#37325;&#23450;&#21521;&#21040; welcome.html</span>
<span class="linenr">20: </span>            response.sendRedirect<span style="color: #E6DB74;">(</span><span style="color: #E6DB74;">"/servletDemo/welcome.html"</span><span style="color: #E6DB74;">)</span>;
<span class="linenr">21: </span>        <span style="color: #A6E22E;">}</span> <span style="color: #F92672;">else</span> <span style="color: #A6E22E;">{</span>
<span class="linenr">22: </span>            <span style="color: #75715E;">// </span><span style="color: #75715E;">&#22914;&#26524;&#29992;&#25143;&#21517;&#21644;&#23494;&#30721;&#38169;&#35823;&#65292;&#37325;&#23450;&#21521;&#21040; login.html</span>
<span class="linenr">23: </span>            response.sendRedirect<span style="color: #E6DB74;">(</span><span style="color: #E6DB74;">"/servletDemo/login.html"</span><span style="color: #E6DB74;">)</span>;
<span class="linenr">24: </span>        <span style="color: #A6E22E;">}</span>
<span class="linenr">25: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">26: </span>
<span class="linenr">27: </span>    <span style="color: #F92672;">public</span> <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">doPost</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">HttpServletRequest</span> <span style="color: #FD971F;">request</span>, <span style="color: #66D9EF;">HttpServletResponse</span> <span style="color: #FD971F;">response</span><span style="color: #66D9EF;">)</span>
<span class="linenr">28: </span>        <span style="color: #F92672;">throws</span> <span style="color: #66D9EF;">ServletException</span>, <span style="color: #66D9EF;">IOException</span> <span style="color: #66D9EF;">{</span>
<span class="linenr">29: </span>        doGet<span style="color: #A6E22E;">(</span>request, response<span style="color: #A6E22E;">)</span>;
<span class="linenr">30: </span>    <span style="color: #66D9EF;">}</span>
<span class="linenr">31: </span><span style="color: #AE81FF;">}</span>
</pre>
</div>

<p>
在上述代码中，首先通过 <code>getParameter()</code> 方法分别获取用户名和密码，然后判断表单中输入的用户名和密码是否为指定的 <code>“admin”</code> 和 <code>“123456”</code> ，如果是，则将请求重定向到 <code>welcome.html</code> 页面，否则重定向到 <code>login.html</code> 页面。
</p>

<p>
<span class="underline">3. 运行项目并查看结果</span>
</p>

<p>
&#x2026;
</p>
</div>
</div>
</div>

<div id="outline-container-orgebe1723" class="outline-2">
<h2 id="orgebe1723">request/response 中文乱码问题</h2>
<div class="outline-text-2" id="text-orgebe1723">
</div>
<div id="outline-container-orge56bbcf" class="outline-3">
<h3 id="orge56bbcf">request 中文乱码问题以及解决方案</h3>
<div class="outline-text-3" id="text-orge56bbcf">
<p>
在填写表单数据时，难免需要输入中文，如用户名和公司名称，提交后控制台的显示乱码，如 <code>é??é??...</code> 。
</p>

<img
src="/images/java/java-39.png"
width="500"
height=""
style=""
title=""
/>

<p>
在 <code>HttpServletRequest</code> 接口中提供了一个 <code>setCharacterEncoding()</code> 方法，该方法用于设置 <code>request</code> 对象的解码方式。
</p>

<pre class="example">
request.setCharacterEncoding("utf-8");    // 设置 request 对象的解码方式
</pre>

<p>
重启 Tomcat 服务器后，再次输入中文即可正确解码。
</p>

<img
src="/images/java/java-40.gif"
width="500"
height=""
style=""
title=""
/>

<p>
*注：这种解决乱码的方式只对 POST 方式有效，而对 GET 方式无效。
</p>

<p>
那么，如何解决 GET 方式提交表单时出现的中文乱码问题，可以先使用错误码表 <code>ISO-8859-1</code> 将用户名重新编码，然后使用码表 <code>UTF-8</code> 进行解码。
</p>

<pre class="example">
name = new String(name.getBytes("iso8859-1"),"utf-8");
</pre>

<p>
重启 Tomcat 服务器后，再次输入中文即可正确解码。
</p>
</div>
</div>

<div id="outline-container-org1709055" class="outline-3">
<h3 id="org1709055">response中文乱码问题以及解决方案</h3>
<div class="outline-text-3" id="text-org1709055">
<p>
由于计算机中的数据都是以二进制形式存储的，因此，当传输文本数据时，会发生字符和字节的转换。
</p>

<p>
字符和字节的转换是通过查码表完成的，将字符转换成字节的过程称为 <span class="underline">编码</span> ，将字节转换成字符的过程称为 <span class="underline">解码</span> ，如果编码和解码使用的码表不一致，则会导致乱码问题。
</p>

<img
src="/images/java/java-41.gif"
width="600"
height=""
style=""
title=""
/>
<p>
<code>Figure：编码错误分析</code>
</p>

<p>
为了解决上述编码错误，HttpServletResponse 对象提供了两种解决乱码的方式，具体如下：
</p>

<pre class="example">
response.setCharacterEncoding("utf-8");                        // 设置 HttpServletResponse 使用 utf-8 编码
response.setHeader("Content-Type", "text/html;charset=utf-8"); // 通知浏览器使用 utf-8 解码
</pre>

<p>
或
</p>

<pre class="example">
response.setContentType("text/html;charset=utf-8");            // 包含第一种方式的两个功能（推荐）
</pre>

<p>
重启 Tomcat 服务器服务器并使用浏览器访问，即可正确解码。
</p>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1304265903570978">https://www.liaoxuefeng.com/wiki/1252599548343744/1304265903570978</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
<a href="http://c.biancheng.net/view/4008.html">http://c.biancheng.net/view/4008.html</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">
<a href="http://c.biancheng.net/view/4013.html">http://c.biancheng.net/view/4013.html</a>
</p></div></div>

</div>
</div></div>
<div id="postamble" class="status">
<p class="date">Date: 2020-10-06 Tue 14:08</p>
<p class="author">Author: Jack Liu</p>
<p class="date">Created: 2020-10-07 Wed 18:48</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
